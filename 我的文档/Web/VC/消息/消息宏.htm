<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv="Content-Language" content="zh-cn">
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<link rel="File-List" href="消息宏.files/filelist.xml">

<title>消息</title>
<link rel="stylesheet" type="text/css" href="../../../Scrpit/样式.css">
<script language="vbscript" src ="../../../Scrpit/webscrpit.bas" >
</script>
<!--[if !mso]>
<style>
v\:*         { behavior: url(#default#VML) }
o\:*         { behavior: url(#default#VML) }
.shape       { behavior: url(#default#VML) }
</style>
<![endif]-->
<style>
</style>
<!--[if gte mso 9]>
<xml><o:shapedefaults v:ext="edit" spidmax="1027"/>
</xml><![endif]-->
</head>

<body>
<p align="center"><b><font size="6">MFC消息处理</font></b></p>
<p align="center">康&nbsp; 林</p>
<p>&nbsp;<span class="ShowLink" id="showall2"  onclick="Call ShowAll()">显示所有文字</span>
</p>
</p>
<p><b><font size="4"><a name="MFC消息处理原理">MFC消息处理原理</a></font></b></p>
<p>MFC利用消息宏保存消息的映射关系。它利用静态数据保存一个 <a href="#AFX_MSGMAP_ENTRY"><span  class ="ShowLink" onclick ="Call Show(afxmsgmapentry)">AFX_MSGMAP_ENTRY</span></a> 
结构数组。这个结构保存有WINDOWS消息，控制代码或WM_NOTIFY代码、控件ID，控件组ID、信号类型（动作）、消息处理函数指等六个信息。
当有消息时，程序检查这个结构数组，找到消息、控制代码或WM_NOTIFY、ID值相符的元素。再通过元素成员信号类型（动作）来判断用什么形式调用消息处理函数。</p>
<table border="1" class="TableStyle" id="afxmsgmapentry" style ="display:none">
			<tr>
				<td>struct <a name="AFX_MSGMAP_ENTRY">AFX_MSGMAP_ENTRY</a><br>
				{<br>
				UINT nMessage; // windows message<br>
				UINT nCode; // control code or WM_NOTIFY code<br>
				UINT nID; // control ID (or 0 for windows messages)<br>
				UINT nLastID; // used for entries specifying a range of control 
				id's<br>
				UINT <span class="ShowLink"  onclick="Call Show(AfxSig)" >nSig</span>; // signature type (action) or pointer to message #
				<table border="1" width="100%" class="TableStyle" id="AfxSig" style="display:none">
					<tr>
						<td>//取下列值之一<br>
						//位置 mfc\include\afxmsg_.h<br>
						enum AfxSig<br>
						{<br>
						AfxSig_end = 0, // [marks end of message map]<br>
						<br>
						AfxSig_bD, // BOOL (CDC*)<br>
						AfxSig_bb, // BOOL (BOOL)<br>
						AfxSig_bWww, // BOOL (CWnd*, UINT, UINT)<br>
						AfxSig_hDWw, // HBRUSH (CDC*, CWnd*, UINT)<br>
						AfxSig_hDw, // HBRUSH (CDC*, UINT)<br>
						AfxSig_iwWw, // int (UINT, CWnd*, UINT)<br>
						AfxSig_iww, // int (UINT, UINT)<br>
						AfxSig_iWww, // int (CWnd*, UINT, UINT)<br>
						AfxSig_is, // int (LPTSTR)<br>
						AfxSig_lwl, // LRESULT (WPARAM, LPARAM)<br>
						AfxSig_lwwM, // LRESULT (UINT, UINT, CMenu*)<br>
						AfxSig_vv, // void (void)<br>
						<br>
						AfxSig_vw, // void (UINT)<br>
						AfxSig_vww, // void (UINT, UINT)<br>
						AfxSig_vvii, // void (int, int) // wParam is ignored<br>
						AfxSig_vwww, // void (UINT, UINT, UINT)<br>
						AfxSig_vwii, // void (UINT, int, int)<br>
						AfxSig_vwl, // void (UINT, LPARAM)<br>
						AfxSig_vbWW, // void (BOOL, CWnd*, CWnd*)<br>
						AfxSig_vD, // void (CDC*)<br>
						AfxSig_vM, // void (CMenu*)<br>
						AfxSig_vMwb, // void (CMenu*, UINT, BOOL)<br>
						<br>
						AfxSig_vW, // void (CWnd*)<br>
						AfxSig_vWww, // void (CWnd*, UINT, UINT)<br>
						AfxSig_vWp, // void (CWnd*, CPoint)<br>
						AfxSig_vWh, // void (CWnd*, HANDLE)<br>
						AfxSig_vwW, // void (UINT, CWnd*)<br>
						AfxSig_vwWb, // void (UINT, CWnd*, BOOL)<br>
						AfxSig_vwwW, // void (UINT, UINT, CWnd*)<br>
						AfxSig_vwwx, // void (UINT, UINT)<br>
						AfxSig_vs, // void (LPTSTR)<br>
						AfxSig_vOWNER, // void (int, LPTSTR), force return TRUE<br>
						AfxSig_iis, // int (int, LPTSTR)<br>
						AfxSig_wp, // UINT (CPoint)<br>
						AfxSig_wv, // UINT (void)<br>
						AfxSig_vPOS, // void (WINDOWPOS*)<br>
						AfxSig_vCALC, // void (BOOL, NCCALCSIZE_PARAMS*)<br>
						AfxSig_vNMHDRpl, // void (NMHDR*, LRESULT*)<br>
						AfxSig_bNMHDRpl, // BOOL (NMHDR*, LRESULT*)<br>
						AfxSig_vwNMHDRpl, // void (UINT, NMHDR*, LRESULT*)<br>
						AfxSig_bwNMHDRpl, // BOOL (UINT, NMHDR*, LRESULT*)<br>
						AfxSig_bHELPINFO, // BOOL (HELPINFO*)<br>
						AfxSig_vwSIZING, // void (UINT, LPRECT) -- return TRUE<br>
						<br>
						// signatures specific to CCmdTarget<br>
						AfxSig_cmdui, // void (CCmdUI*)<br>
						AfxSig_cmduiw, // void (CCmdUI*, UINT)<br>
						AfxSig_vpv, // void (void*)<br>
						AfxSig_bpv, // BOOL (void*)<br>
						<br>
						// Other aliases (based on implementation)<br>
						AfxSig_vwwh, // void (UINT, UINT, HANDLE)<br>
						AfxSig_vwp, // void (UINT, CPoint)<br>
						AfxSig_bw = AfxSig_bb, // BOOL (UINT)<br>
						AfxSig_bh = AfxSig_bb, // BOOL (HANDLE)<br>
						AfxSig_iw = AfxSig_bb, // int (UINT)<br>
						AfxSig_ww = AfxSig_bb, // UINT (UINT)<br>
						AfxSig_bv = AfxSig_wv, // BOOL (void)<br>
						AfxSig_hv = AfxSig_wv, // HANDLE (void)<br>
						AfxSig_vb = AfxSig_vw, // void (BOOL)<br>
						AfxSig_vbh = AfxSig_vww, // void (BOOL, HANDLE)<br>
						AfxSig_vbw = AfxSig_vww, // void (BOOL, UINT)<br>
						AfxSig_vhh = AfxSig_vww, // void (HANDLE, HANDLE)<br>
						AfxSig_vh = AfxSig_vw, // void (HANDLE)<br>
						AfxSig_viSS = AfxSig_vwl, // void (int, STYLESTRUCT*)<br>
						AfxSig_bwl = AfxSig_lwl,<br>
						AfxSig_vwMOVING = AfxSig_vwSIZING, // void (UINT, 
						LPRECT) -- return TRUE<br>
						<br>
						AfxSig_vW2, // void (CWnd*) (CWnd* comes from lParam)<br>
						AfxSig_bWCDS, // BOOL (CWnd*, COPYDATASTRUCT*)<br>
						AfxSig_bwsp, // BOOL (UINT, short, CPoint)<br>
						AfxSig_vws,<br>
						};</td>
					</tr>
				</table><br>
				<span class="ShowLink" onclick="Call Show(afxpmsg)">AFX_PMSG</span> pfn; // routine to call (or special value)
　<table border="1" width="100%" class="TableStyle" style="display:none" id="afxpmsg">
					<tr>
						<td>//位置：mfc\include\afxwin.h<br>
						// pointer to afx_msg member function<br>
						#ifndef AFX_MSG_CALL<br>
						#define AFX_MSG_CALL<br>
						#endif<br>
						typedef void (AFX_MSG_CALL CCmdTarget::*AFX_PMSG)(void);</td>
					</tr>
				</table>
				};
				<p></p>
				<span class="ShowLink" onclick="Call Show(AFX_MSGMAP_ENTRY_FORMAT)">//其格式</span> 
				<table border="1" width="100%" class="TableStyle" style="display:none" id="AFX_MSGMAP_ENTRY_FORMAT">
	<tr>
		<td>
		//位置:mfc\include\afxmsg_.h<br>
		/////////////////////////////////////////////////////////////////////////////<br>
		<br>
		// Entries in a message map (a 'AFX_MSGMAP_ENTRY') table can be of 9 
		formats<br>
		//<br>
		// 1) control notification message (i.e. in response to WM_COMMAND)<br>
		// WM_COMMAND, nNotifyCode, nControlID, nControlID, signature type, 
		parameterless member function<br>
		// (eg: WM_COMMAND, LBN_SELCHANGE, IDC_LISTBOX, AfxSig_vv, ... )<br>
		// 2) control notification message range (i.e. in response to 
		WM_COMMAND)<br>
		// WM_COMMAND, nNotifyCode, nControlIDFirst, nControlIDLast, signature 
		type, parameterless member function<br>
		// (eg: WM_COMMAND, LBN_SELCHANGE, IDC_LISTBOX1, IDC_LISTBOX5, 
		AfxSig_vw, ... )<br>
		// 3) WM_NOTIFY notification<br>
		// WM_NOTIFY, nNotifyCode, nControlID, nControlID, signature type, ...)<br>
		// 3) Update Command UI<br>
		// -1, 0, nControlID, 0, signature Unknown, parameterless member 
		function<br>
		// 4) Update Command UI Range<br>
		// -1, 0, nControlIDFirst, nControlIDLast, signature Unknown, 
		parameterless member function<br>
		// 5) menu/accelerator notification message (i.e. special case of first 
		format)<br>
		// WM_COMMAND, 0, nID, 0, signature type, parameterless member function<br>
		// (eg: WM_COMMAND, 0, IDM_FILESAVE, 0, AfxSig_vv, ... )<br>
		// 6) menu/accelerator notification message range<br>
		// WM_COMMAND, 0, nIDFirst, nIDLast, signature type, parameterless 
		member function<br>
		// (eg: WM_COMMAND, 0, IDM_FILE_MRU1, IDM_FILE_MRU4, AfxSig_vw, ... )<br>
		// 7) constant windows message<br>
		// nMessage, 0, 0, 0, signature type, member function<br>
		// (eg: WM_PAINT, 0, ...)<br>
		// 8) variable windows message (using RegisterWindowMessage)<br>
		// 0xC000, 0, 0, 0, &amp;nMessage, special member function<br>
		//<br>
		// The end of the message map is marked with a special value<br>
		// 0, 0, AfxSig_end, 0<br>
		/////////////////////////////////////////////////////////////////////////////
		</td>
	</tr>
</table>
				</td>
			</tr>
		</table>
		
<p><b><font size="5"><a name="消息宏">消息宏</a></font></b><br>
<span class="ShowLink" onclick ="Call Show(messagemarco)">
<a href="#DECLARE_MESSAGE_MAP()">DECLARE_MESSAGE_MAP()</a><br>
<a href="#BEGIN_MESSAGE_MAP">BEGIN_MESSAGE_MAP(theClass, baseClass)</a><br>
<a href="#END_MESSAGE_MAP()">END_MESSAGE_MAP()</a>
</span>
<br>
</p>
<table border="1" width="100%" class="TableStyle" id="messagemarco" style="display:none">
	<tr>
		<td>
		//位置:mfc\include\afxwin.h<br>
		/////////////////////////////////////////////////////////////////////////////<br>
		// Window message map handling<br>
		<br>
		struct AFX_MSGMAP_ENTRY; // declared below after CWnd<br>
		
		<br>
		struct <a name="AFX_MSGMAP">AFX_MSGMAP</a><br>
		{<br>
		#ifdef _AFXDLL<br>
		const AFX_MSGMAP* (PASCAL* pfnGetBaseMap)();<br>
		#else<br>
		const AFX_MSGMAP* pBaseMap;<br>
		#endif<br>
		const AFX_MSGMAP_ENTRY* lpEntries;<br>
		};<br>
		<br>
		#ifdef _AFXDLL<br>
		#define <a name="DECLARE_MESSAGE_MAP()">DECLARE_MESSAGE_MAP()</a> \<br>
		private: \<br>
		static const <a href="#AFX_MSGMAP_ENTRY"><span  class ="ShowLink" onclick ="Call Show(afxmsgmapentry)">AFX_MSGMAP_ENTRY</span></a> 
		_messageEntries[]; \<br>
		protected: \<br>
		static AFX_DATA const <a href="#AFX_MSGMAP">AFX_MSGMAP</a> messageMap; \<br>
		static const AFX_MSGMAP* PASCAL _GetBaseMessageMap(); \<br>
		virtual const AFX_MSGMAP* GetMessageMap() const; \<br>
		<br>
		#else<br>
		#define DECLARE_MESSAGE_MAP() \<br>
		private: \<br>
		static const&nbsp; <a href="#AFX_MSGMAP_ENTRY"><span  class ="ShowLink" onclick ="Call Show(afxmsgmapentry)">AFX_MSGMAP_ENTRY</span></a>&nbsp; _messageEntries[]; \<br>
		protected: \<br>
		static AFX_DATA const AFX_MSGMAP messageMap; \<br>
		virtual const AFX_MSGMAP* GetMessageMap() const; \<br>
		<br>
		#endif<br>
		<br>
		#ifdef _AFXDLL<br>
		#define <a name="BEGIN_MESSAGE_MAP">BEGIN_MESSAGE_MAP</a>(theClass, baseClass) \<br>
		const AFX_MSGMAP* PASCAL theClass::_GetBaseMessageMap() \<br>
		{ return &amp;baseClass::messageMap; } \<br>
		const AFX_MSGMAP* theClass::GetMessageMap() const \<br>
		{ return &amp;theClass::messageMap; } \<br>
		AFX_COMDAT AFX_DATADEF const AFX_MSGMAP theClass::messageMap = \<br>
		{ &amp;theClass::_GetBaseMessageMap, &amp;theClass::_messageEntries[0] }; \<br>
		AFX_COMDAT const AFX_MSGMAP_ENTRY theClass::_messageEntries[] = \<br>
		{ \<br>
		<br>
		#else<br>
		#define BEGIN_MESSAGE_MAP(theClass, baseClass) \<br>
		const AFX_MSGMAP* theClass::GetMessageMap() const \<br>
		{ return &amp;theClass::messageMap; } \<br>
		AFX_COMDAT AFX_DATADEF const AFX_MSGMAP theClass::messageMap = \<br>
		{ &amp;baseClass::messageMap, &amp;theClass::_messageEntries[0] }; \<br>
		AFX_COMDAT const AFX_MSGMAP_ENTRY theClass::_messageEntries[] = \<br>
		{ \<br>
		<br>
		#endif<br>
		<br>
		#define <a name="END_MESSAGE_MAP()">END_MESSAGE_MAP()</a> \<br>
		{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } \<br>
		}; \<br>
		<br>
		// Message map signature values and macros in separate header<br>
		#include &lt;afxmsg_.h&gt;<br>
　</td>
	</tr>
</table>

<p><samp class ="ShowLink" onclick ="call show(MFCAPPMESSAGEPROCESS)">MFC应用程序的消息处理过程</samp></p>
<p>// 主要处理过程<br>
				//从消息队列中得到消息<br>
				if (!::<a href="消息函数.htm#GetMessage">GetMessage</a>(&amp;m_msgCur, NULL, NULL, NULL)))<br>
				{<br>
				::<a href="消息函数.htm#TranslateMessage">TranslateMessage</a>(&amp;m_msgCur);//转换消息<br>
				::<a href="消息函数.htm#DispatchMessage">DispatchMessage</a>(&amp;m_msgCur);//派遣消息<br>
				}<br>
				return TRUE;<br>
				}</p>
<table id="MFCAPPMESSAGEPROCESS" style ="display:none" class="TableStyle" border="1">
	<tr>
		<td>//位置: mfc\src\appcore.cpp<br>
		// Main running routine until application exits<br>
		<b>int CWinApp::Run()</b><br>
		{<br>
		if (m_pMainWnd == NULL &amp;&amp; AfxOleGetUserCtrl())<br>
		{<br>
		// Not launched /Embedding or /Automation, but has no main window!<br>
		TRACE0(&quot;Warning: m_pMainWnd is NULL in CWinApp::Run - quitting 
		application.\n&quot;);<br>
		AfxPostQuitMessage(0);<br>
		}<br>
		return <span class="ShowLink"  onclick ="Call Show(CWinThreadRun)">CWinThread::Run()</span>;<br>
　<table border="1" class="TableStyle" id="CWinThreadRun" style="display:none">
			<tr>
				<td>//位置:mfc\src\thrdcore.cpp<p>
				// main running routine until thread exits<br>
				<b>int CWinThread::Run()</b><br>
				{<br>
				ASSERT_VALID(this);<br>
				<br>
				// for tracking the idle time state<br>
				BOOL bIdle = TRUE;<br>
				LONG lIdleCount = 0;<br>
				<br>
				// acquire and dispatch messages until a WM_QUIT message is 
				received.<br>
				for (;;)<br>
				{<br>
				// phase1: check to see if we can do idle work<br>
				while (bIdle &amp;&amp;<br>
				!::<a href="消息函数.htm#PeekMessage">PeekMessage</a>(&amp;m_msgCur, NULL, NULL, NULL, PM_NOREMOVE))<br>
				{<br>
				// call OnIdle while in bIdle state<br>
				if (!OnIdle(lIdleCount++))<br>
				bIdle = FALSE; // assume &quot;no idle&quot; state<br>
				}<br>
				<br>
				// phase2: pump messages while available<br>
				do<br>
				{<br>
				// pump message, but quit on WM_QUIT<br>
				if (!<a href="#PumpMessage">PumpMessage</a>())<br>
				return ExitInstance();<br>
				<br>
				// reset &quot;no idle&quot; state after pumping &quot;normal&quot; message<br>
				if (IsIdleMessage(&amp;m_msgCur))<br>
				{<br>
				bIdle = TRUE;<br>
				lIdleCount = 0;<br>
				}<br>
				<br>
				} while (::<a href="消息函数.htm#PeekMessage">PeekMessage</a>(&amp;m_msgCur, NULL, NULL, NULL, 
				PM_NOREMOVE));<br>
				}<br>
				<br>
				ASSERT(FALSE); // not reachable<br>
				}<p>
				BOOL CWinThread::<a name="PumpMessage">PumpMessage</a>()<br>
				{<br>
				ASSERT_VALID(this);<br>
				<br>
				if (!::<a href="消息函数.htm#GetMessage">GetMessage</a>(&amp;m_msgCur, NULL, NULL, NULL))<br>
				{<br>
				#ifdef _DEBUG<br>
				if (afxTraceFlags &amp; traceAppMsg)<br>
				TRACE0(&quot;CWinThread::PumpMessage - Received WM_QUIT.\n&quot;);<br>
				m_nDisablePumpCount++; // application must die<br>
				// Note: prevents calling message loop things in 'ExitInstance'<br>
				// will never be decremented<br>
				#endif<br>
				return FALSE;<br>
				}<br>
				<br>
				#ifdef _DEBUG<br>
				if (m_nDisablePumpCount != 0)<br>
				{<br>
				TRACE0(&quot;Error: CWinThread::PumpMessage called when not 
				permitted.\n&quot;);<br>
				ASSERT(FALSE);<br>
				}<br>
				#endif<br>
				<br>
				#ifdef _DEBUG<br>
				if (afxTraceFlags &amp; traceAppMsg)<br>
				_AfxTraceMsg(_T(&quot;PumpMessage&quot;), &amp;m_msgCur);<br>
				#endif<br>
				<br>
				// process this message<br>
				<br>
				if (m_msgCur.message != WM_KICKIDLE &amp;&amp; 
				!<a href="#PreTranslateMessage">PreTranslateMessage</a>(&amp;m_msgCur))<br>
				{<br>
				<span style="background-color: #FF0000">::</span><a href="消息函数.htm#TranslateMessage"><span style="background-color: #FF0000">TranslateMessage</span></a><span style="background-color: #FF0000">(&amp;m_msgCur);<br>
				::</span><a href="消息函数.htm#DispatchMessage"><span style="background-color: #FF0000">DispatchMessage</span></a><span style="background-color: #FF0000">(&amp;m_msgCur);</span><br>
				}<br>
				return TRUE;<br>
				}<p>
				BOOL CWinThread::<a name="PreTranslateMessage">PreTranslateMessage</a>(MSG* pMsg)<br>
				{<br>
				ASSERT_VALID(this);<br>
				<br>
				// if this is a thread-message, short-circuit this function<br>
				if (pMsg-&gt;hwnd == NULL &amp;&amp; DispatchThreadMessageEx(pMsg))<br>
				return TRUE;<br>
				<br>
				// walk from target to main window<br>
				CWnd* pMainWnd = AfxGetMainWnd();<br>
				if (CWnd::WalkPreTranslateTree(pMainWnd-&gt;GetSafeHwnd(), pMsg))<br>
				return TRUE;<br>
				<br>
				// in case of modeless dialogs, last chance route through main<br>
				// window's accelerator table<br>
				if (pMainWnd != NULL)<br>
				{<br>
				CWnd* pWnd = CWnd::FromHandle(pMsg-&gt;hwnd);<br>
				if (pWnd-&gt;GetTopLevelParent() != pMainWnd)<br>
				return pMainWnd-&gt;PreTranslateMessage(pMsg);<br>
				}<br>
				<br>
				return FALSE; // no special processing<br>
				}</td>
			</tr>
		</table>
		<br>
		}</td>
	</tr>
</table>
<p>当有消息时，调用
<span class ="ShowLink" onclick ="Call Show(WindowProctable)">WindowProc</span>&nbsp; 处理消息 
。</p>
<p>　</p>
<p><!--[if gte vml 1]><v:group id="_x0000_s1052"
 alt="" style='width:447.75pt;height:291pt' coordorigin="11,17443" coordsize="597,388">
 <o:lock v:ext="edit" aspectratio="t"/>
 <v:rect id="_x0000_s1051" alt="" style='position:absolute;left:208;top:17809;
  width:167;height:22;mso-wrap-style:square;mso-wrap-distance-left:9pt;
  mso-wrap-distance-top:0;mso-wrap-distance-right:9pt;
  mso-wrap-distance-bottom:0;mso-position-horizontal-relative:text;
  mso-position-vertical:absolute;mso-position-vertical-relative:text;
  v-text-anchor:top'>
  <o:lock v:ext="edit" aspectratio="t"/>
  <v:textbox inset="0,0,0,0">
<table cellspacing="0" cellpadding="0" width="100%" height="100%">
	<tr>
		<td align="center">处理过程</td>
	</tr>
</table>
  </v:textbox>
 </v:rect><v:group id="_x0000_s1047" style='position:absolute;left:11;top:17443;
  width:597;height:202' coordorigin="116,17548" coordsize="597,202"
  o:regroupid="1">
  <o:lock v:ext="edit" aspectratio="t"/>
  <v:group id="_x0000_s1045" style='position:absolute;left:312;top:17548;
   width:96;height:49' coordorigin="309,17542" coordsize="96,49">
   <o:lock v:ext="edit" aspectratio="t"/>
   <v:rect id="_x0000_s1025" alt="" style='position:absolute;left:309;top:17542;
    width:96;height:23'>
    <o:lock v:ext="edit" aspectratio="t"/>
    <v:textbox inset="0,0,0,0">
<table cellspacing="0" cellpadding="0" width="100%" height="100%">
	<tr>
		<td align="center">WindProc</td>
	</tr>
</table>
    </v:textbox>
   </v:rect><v:line id="_x0000_s1029" style='position:absolute;
    mso-wrap-style:square;mso-wrap-distance-left:9pt;mso-wrap-distance-top:0;
    mso-wrap-distance-right:9pt;mso-wrap-distance-bottom:0;
    mso-position-horizontal-relative:text;mso-position-vertical:absolute;
    mso-position-vertical-relative:text;v-text-anchor:top' from="354,17565"
    to="354,17591">
    <v:stroke endarrow="block"/>
    <o:lock v:ext="edit" aspectratio="t"/>
   </v:line></v:group><v:rect id="_x0000_s1030" style='position:absolute;
   left:308;top:17597;width:99;height:21;mso-wrap-style:square;
   mso-wrap-distance-left:9pt;mso-wrap-distance-top:0;
   mso-wrap-distance-right:9pt;mso-wrap-distance-bottom:0;
   mso-position-horizontal-relative:text;mso-position-vertical:absolute;
   mso-position-vertical-relative:text;v-text-anchor:top'>
   <o:lock v:ext="edit" aspectratio="t"/>
   <v:textbox inset="0,0,0,0">
<table cellspacing="0" cellpadding="0" width="100%" height="100%">
	<tr>
		<td align="center">OnWndMsg</td>
	</tr>
</table>
   </v:textbox>
  </v:rect><v:line id="_x0000_s1031" style='position:absolute;mso-wrap-style:square;
   mso-wrap-distance-left:9pt;mso-wrap-distance-top:0;
   mso-wrap-distance-right:9pt;mso-wrap-distance-bottom:0;
   mso-position-horizontal-relative:text;mso-position-vertical:absolute;
   mso-position-vertical-relative:text;v-text-anchor:top' from="358,17618"
   to="358,17662">
   <o:lock v:ext="edit" aspectratio="t"/>
  </v:line><v:line id="_x0000_s1032" style='position:absolute;mso-wrap-style:square;
   mso-wrap-distance-left:9pt;mso-wrap-distance-top:0;
   mso-wrap-distance-right:9pt;mso-wrap-distance-bottom:0;
   mso-position-horizontal-relative:text;mso-position-vertical:absolute;
   mso-position-vertical-relative:text;v-text-anchor:top' from="160,17662"
   to="616,17662">
   <o:lock v:ext="edit" aspectratio="t"/>
  </v:line><v:line id="_x0000_s1037" style='position:absolute;mso-wrap-style:square;
   mso-wrap-distance-left:9pt;mso-wrap-distance-top:0;
   mso-wrap-distance-right:9pt;mso-wrap-distance-bottom:0;
   mso-position-horizontal-relative:text;mso-position-vertical:absolute;
   mso-position-vertical-relative:text;v-text-anchor:top' from="433,17663"
   to="433,17699">
   <v:stroke endarrow="block"/>
   <o:lock v:ext="edit" aspectratio="t"/>
  </v:line><v:line id="_x0000_s1039" style='position:absolute;mso-wrap-style:square;
   mso-wrap-distance-left:9pt;mso-wrap-distance-top:0;
   mso-wrap-distance-right:9pt;mso-wrap-distance-bottom:0;
   mso-position-horizontal-relative:text;mso-position-vertical:absolute;
   mso-position-vertical-relative:text;v-text-anchor:top' from="616,17662"
   to="616,17698">
   <v:stroke endarrow="block"/>
   <o:lock v:ext="edit" aspectratio="t"/>
  </v:line><v:line id="_x0000_s1035" style='position:absolute;mso-wrap-style:square;
   mso-wrap-distance-left:9pt;mso-wrap-distance-top:0;
   mso-wrap-distance-right:9pt;mso-wrap-distance-bottom:0;
   mso-position-horizontal-relative:text;mso-position-vertical:absolute;
   mso-position-vertical-relative:text;v-text-anchor:top' from="304,17662"
   to="304,17696">
   <v:stroke endarrow="block"/>
   <o:lock v:ext="edit" aspectratio="t"/>
  </v:line><v:line id="_x0000_s1033" style='position:absolute;mso-wrap-style:square;
   mso-wrap-distance-left:9pt;mso-wrap-distance-top:0;
   mso-wrap-distance-right:9pt;mso-wrap-distance-bottom:0;
   mso-position-horizontal-relative:text;mso-position-vertical:absolute;
   mso-position-vertical-relative:text;v-text-anchor:top' from="160,17663"
   to="160,17699">
   <v:stroke endarrow="block"/>
   <o:lock v:ext="edit" aspectratio="t"/>
  </v:line><v:rect id="_x0000_s1038" style='position:absolute;left:384;top:17698;
   width:98;height:24;mso-wrap-style:square;mso-wrap-distance-left:9pt;
   mso-wrap-distance-top:0;mso-wrap-distance-right:9pt;
   mso-wrap-distance-bottom:0;mso-position-horizontal-relative:text;
   mso-position-vertical:absolute;mso-position-vertical-relative:text;
   v-text-anchor:top'>
   <o:lock v:ext="edit" aspectratio="t"/>
   <v:textbox inset="0,0,0,0">
<table cellspacing="0" cellpadding="0" width="100%" height="100%">
	<tr>
		<td align="center">WM_ACTIVATE</td>
	</tr>
</table>
   </v:textbox>
  </v:rect><v:rect id="_x0000_s1040" alt="" style='position:absolute;left:518;
   top:17697;width:195;height:23;mso-wrap-style:square;
   mso-wrap-distance-left:9pt;mso-wrap-distance-top:0;
   mso-wrap-distance-right:9pt;mso-wrap-distance-bottom:0;
   mso-position-horizontal-relative:text;mso-position-vertical:absolute;
   mso-position-vertical-relative:text;v-text-anchor:top'>
   <o:lock v:ext="edit" aspectratio="t"/>
   <v:textbox inset="0,0,0,0">
<table cellspacing="0" cellpadding="0" width="100%" height="100%">
	<tr>
		<td align="center">
		<a href="file:///C:/Documents%20and%20Settings/kl/Local%20Settings/Temporary%20Internet%20Files/FrontPageTempDir/pvw1B.htm#AfxFindMessageEntry">
		AfxFindMessageEntry</a></td>
	</tr>
</table>
   </v:textbox>
  </v:rect><v:rect id="_x0000_s1036" style='position:absolute;left:252;top:17698;
   width:101;height:25;mso-wrap-style:square;mso-wrap-distance-left:9pt;
   mso-wrap-distance-top:0;mso-wrap-distance-right:9pt;
   mso-wrap-distance-bottom:0;mso-position-horizontal-relative:text;
   mso-position-vertical:absolute;mso-position-vertical-relative:text;
   v-text-anchor:top'>
   <o:lock v:ext="edit" aspectratio="t"/>
   <v:textbox inset="0,0,0,0">
<table cellspacing="0" cellpadding="0" width="100%" height="100%">
	<tr>
		<td align="center">OnNotify</td>
	</tr>
</table>
   </v:textbox>
  </v:rect><v:rect id="_x0000_s1034" style='position:absolute;left:116;top:17699;
   width:86;height:26;mso-wrap-style:square;mso-wrap-distance-left:9pt;
   mso-wrap-distance-top:0;mso-wrap-distance-right:9pt;
   mso-wrap-distance-bottom:0;mso-position-horizontal-relative:text;
   mso-position-vertical:absolute;mso-position-vertical-relative:text;
   v-text-anchor:top'>
   <o:lock v:ext="edit" aspectratio="t"/>
   <v:textbox inset="0,0,0,0">
<table cellspacing="0" cellpadding="0" width="100%" height="100%">
	<tr>
		<td align="center">OnCommand</td>
	</tr>
</table>
   </v:textbox>
  </v:rect><v:line id="_x0000_s1041" style='position:absolute;mso-wrap-style:square;
   mso-wrap-distance-left:9pt;mso-wrap-distance-top:0;
   mso-wrap-distance-right:9pt;mso-wrap-distance-bottom:0;
   mso-position-horizontal-relative:text;mso-position-vertical:absolute;
   mso-position-vertical-relative:text;v-text-anchor:top' from="616,17720"
   to="616,17750">
   <v:stroke endarrow="block"/>
   <o:lock v:ext="edit" aspectratio="t"/>
  </v:line></v:group><v:group id="_x0000_s1048" style='position:absolute;
  left:419;top:17645;width:186;height:135' coordorigin="525,17754" coordsize="186,135"
  o:regroupid="1">
  <o:lock v:ext="edit" aspectratio="t"/>
  <v:shapetype id="_x0000_t4" coordsize="21600,21600" o:spt="4" path="m10800,l,10800,10800,21600,21600,10800xe">
   <v:stroke joinstyle="miter"/>
   <v:path gradientshapeok="t" o:connecttype="rect" textboxrect="5400,5400,16200,16200"/>
  </v:shapetype><v:shape id="_x0000_s1042" type="#_x0000_t4" style='position:absolute;
   left:525;top:17754;width:186;height:61;mso-wrap-style:square;
   mso-wrap-distance-left:9pt;mso-wrap-distance-top:0;
   mso-wrap-distance-right:9pt;mso-wrap-distance-bottom:0;
   mso-position-horizontal-relative:text;mso-position-vertical:absolute;
   mso-position-vertical-relative:text;v-text-anchor:top'>
   <o:lock v:ext="edit" aspectratio="t"/>
   <v:textbox inset="0,0,0,0">
<table cellspacing="0" cellpadding="0" width="100%" height="100%">
	<tr>
		<td align="center">nSig</td>
	</tr>
</table>
   </v:textbox>
  </v:shape><v:line id="_x0000_s1043" style='position:absolute;
   mso-wrap-style:square;mso-wrap-distance-left:9pt;mso-wrap-distance-top:0;
   mso-wrap-distance-right:9pt;mso-wrap-distance-bottom:0;
   mso-position-horizontal-relative:text;mso-position-vertical:absolute;
   mso-position-vertical-relative:text;v-text-anchor:top' from="617,17818"
   to="617,17859">
   <v:stroke endarrow="block"/>
   <o:lock v:ext="edit" aspectratio="t"/>
  </v:line><v:rect id="_x0000_s1044" style='position:absolute;left:556;top:17860;
   width:119;height:29;mso-wrap-style:square;mso-wrap-distance-left:9pt;
   mso-wrap-distance-top:0;mso-wrap-distance-right:9pt;
   mso-wrap-distance-bottom:0;mso-position-horizontal-relative:text;
   mso-position-vertical:absolute;mso-position-vertical-relative:text;
   v-text-anchor:top'>
   <o:lock v:ext="edit" aspectratio="t"/>
   <v:textbox inset="0,0,0,0">
<table cellspacing="0" cellpadding="0" width="100%" height="100%">
	<tr>
		<td align="center">pfn</td>
	</tr>
</table>
   </v:textbox>
  </v:rect></v:group></v:group><![endif]--><![if !vml]><img width=603
height=394 src="消息宏.files/image001.gif" v:shapes="_x0000_s1052 _x0000_s1051 _x0000_s1047 _x0000_s1045 _x0000_s1025 _x0000_s1029 _x0000_s1030 _x0000_s1031 _x0000_s1032 _x0000_s1037 _x0000_s1039 _x0000_s1035 _x0000_s1033 _x0000_s1038 _x0000_s1040 _x0000_s1036 _x0000_s1034 _x0000_s1041 _x0000_s1048 _x0000_s1042 _x0000_s1043 _x0000_s1044"><![endif]></p>
<p>　</p>
<p>&nbsp;<b><a href="#AfxFindMessageEntry">AfxFindMessageEntry</a> </b>在 
<a href="#AFX_MSGMAP_ENTRY">AFX_MSGMAP_ENTRY</a> 队列中按照 (UINT nMsg, UINT nCode, UINT nID)找到含有这个信息的 
AFX_MSGMAP_ENTRY 结构,并从中取出消息函数。再通过判断结构 AFX_MSGMAP_ENTRY 中的 nSig 成员，调用什么样的函数指针。</p>
<table border="1" width="731" class="TableStyle" id="WindowProctable" style ="display:none">
	<tr>
		<td>
		/////////////////////////////////////////////////////////////////////////////<br>
		// main WindowProc implementation<br>
		<br>
		LRESULT CWnd::<b><a name="WindowProc">WindowProc</a></b>(UINT message, WPARAM wParam, LPARAM lParam)<br>
		{<br>
&nbsp;&nbsp;&nbsp;&nbsp;
		// OnWndMsg does most of the work, except for DefWindowProc call<br>
&nbsp;&nbsp;&nbsp;&nbsp;
		LRESULT lResult = 0;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		if (!OnWndMsg(message, wParam, lParam, &amp;lResult))<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = DefWindowProc(message, wParam, lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		return lResult;<br>
		}</td>
	</tr>
	<tr>
		<td>
		<br>
		BOOL CWnd::<b>OnWndMsg</b>(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* 
		pResult)<br>
		{<br>
&nbsp;&nbsp;&nbsp;&nbsp;
		LRESULT lResult = 0;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		// special case for commands<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		if (message == WM_COMMAND)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (<a href="#CWnd::OnCommand">OnCommand</a>(wParam, lParam))<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = 1;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		goto LReturnTrue;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		return FALSE;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// special case for notifies<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (message == WM_NOTIFY)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		NMHDR* pNMHDR = (NMHDR*)lParam;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (pNMHDR-&gt;hwndFrom != NULL &amp;&amp; <a href="#CWnd::OnNotify">OnNotify</a>(wParam, lParam, &amp;lResult))<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		goto LReturnTrue;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		return FALSE;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// special case for activation<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (message == WM_ACTIVATE)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		_AfxHandleActivate(this, wParam, CWnd::FromHandle((HWND)lParam));<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// special case for set cursor HTERROR<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (message == WM_SETCURSOR &amp;&amp;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		_AfxHandleSetCursor(this, (short)LOWORD(lParam), HIWORD(lParam)))<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = 1;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		goto LReturnTrue;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		const AFX_MSGMAP* pMessageMap; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMessageMap = GetMessageMap();<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		UINT iHash; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iHash = (LOWORD((DWORD)pMessageMap) ^ message) &amp; 
		(iHashMax-1);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		AfxLockGlobals(CRIT_WINMSGCACHE);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		AFX_MSG_CACHE* pMsgCache; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pMsgCache = &amp;_afxMsgCache[iHash];<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		const AFX_MSGMAP_ENTRY* lpEntry;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (message == pMsgCache-&gt;nMsg &amp;&amp; pMessageMap == pMsgCache-&gt;pMessageMap)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// cache hit<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lpEntry = pMsgCache-&gt;lpEntry;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		AfxUnlockGlobals(CRIT_WINMSGCACHE);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (lpEntry == NULL)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		return FALSE;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// cache hit, and it needs to be handled<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (message &lt; 0xC000)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		goto LDispatch;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		else<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		goto LDispatchRegistered;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		else<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// not in cache, look for it<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		pMsgCache-&gt;nMsg = message;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		pMsgCache-&gt;pMessageMap = pMessageMap;<br>
		<br>
		#ifdef _AFXDLL<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		for (/* pMessageMap already init'ed */; pMessageMap != NULL;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		pMessageMap = (*pMessageMap-&gt;pfnGetBaseMap)())<br>
		#else<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		for (/* pMessageMap already init'ed */; pMessageMap != NULL;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		pMessageMap = pMessageMap-&gt;pBaseMap)<br>
		#endif<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// Note: catch not so common but fatal mistake!!<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// BEGIN_MESSAGE_MAP(CMyWnd, CMyWnd)<br>
		#ifdef _AFXDLL<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		ASSERT(pMessageMap != (*pMessageMap-&gt;pfnGetBaseMap)());<br>
		#else<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		ASSERT(pMessageMap != pMessageMap-&gt;pBaseMap);<br>
		#endif<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (message &lt; 0xC000)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// constant window message<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if ((lpEntry = <a href="#AfxFindMessageEntry">AfxFindMessageEntry</a>(pMessageMap-&gt;lpEntries,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		message, 0, 0)) != NULL)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		pMsgCache-&gt;lpEntry = lpEntry;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		AfxUnlockGlobals(CRIT_WINMSGCACHE);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		goto LDispatch;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		else<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// registered windows message<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lpEntry = pMessageMap-&gt;lpEntries;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		while ((lpEntry = AfxFindMessageEntry(lpEntry, 0xC000, 0, 0)) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; != NULL)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		UINT* pnID = (UINT*)(lpEntry-&gt;nSig);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		ASSERT(*pnID &gt;= 0xC000 || *pnID == 0);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// must be successfully registered<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (*pnID == message)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		pMsgCache-&gt;lpEntry = lpEntry;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		AfxUnlockGlobals(CRIT_WINMSGCACHE);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		goto LDispatchRegistered;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lpEntry++; // keep looking past this one<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}//while((lpEntry = AfxFindMessageEntry(lpEntry, 0xC000, 0, 0)) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; != NULL)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}//if(message &lt; 0xC000)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}//for<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		pMsgCache-&gt;lpEntry = NULL;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		AfxUnlockGlobals(CRIT_WINMSGCACHE);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		return FALSE;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}//if (message == pMsgCache-&gt;nMsg &amp;&amp; pMessageMap == pMsgCache-&gt;pMessageMap)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		ASSERT(FALSE); // not reached<br>
		<br>
		LDispatch:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		ASSERT(message &lt; 0xC000);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		union <span class="ShowLink" onclick="Call Show(messagemapfunctionstable)">MessageMapFunctions</span> mmf;<table border="1" style="display:none" width="100%" class="TableStyle" id="messagemapfunctionstable">
			<tr>
				<td>union MessageMapFunctions<br>
				{<br>
				AFX_PMSG pfn; // generic member function pointer<br>
				<br>
				// specific type safe variants for WM_COMMAND and WM_NOTIFY 
				messages<br>
				void (AFX_MSG_CALL CCmdTarget::*pfn_COMMAND)();<br>
				BOOL (AFX_MSG_CALL CCmdTarget::*pfn_bCOMMAND)();<br>
				void (AFX_MSG_CALL CCmdTarget::*pfn_COMMAND_RANGE)(UINT);<br>
				BOOL (AFX_MSG_CALL CCmdTarget::*pfn_COMMAND_EX)(UINT);<br>
				<br>
				void (AFX_MSG_CALL CCmdTarget::*pfn_UPDATE_COMMAND_UI)(CCmdUI*);<br>
				void (AFX_MSG_CALL 
				CCmdTarget::*pfn_UPDATE_COMMAND_UI_RANGE)(CCmdUI*, UINT);<br>
				void (AFX_MSG_CALL CCmdTarget::*pfn_OTHER)(void*);<br>
				BOOL (AFX_MSG_CALL CCmdTarget::*pfn_OTHER_EX)(void*);<br>
				<br>
				void (AFX_MSG_CALL CCmdTarget::*pfn_NOTIFY)(NMHDR*, LRESULT*);<br>
				BOOL (AFX_MSG_CALL CCmdTarget::*pfn_bNOTIFY)(NMHDR*, LRESULT*);<br>
				void (AFX_MSG_CALL CCmdTarget::*pfn_NOTIFY_RANGE)(UINT, NMHDR*, 
				LRESULT*);<br>
				BOOL (AFX_MSG_CALL CCmdTarget::*pfn_NOTIFY_EX)(UINT, NMHDR*, 
				LRESULT*);<br>
				<br>
				// type safe variant for thread messages<br>
				<br>
				void (AFX_MSG_CALL CWinThread::*pfn_THREAD)(WPARAM, LPARAM);<br>
				<br>
				// specific type safe variants for WM-style messages<br>
				BOOL (AFX_MSG_CALL CWnd::*pfn_bD)(CDC*);<br>
				BOOL (AFX_MSG_CALL CWnd::*pfn_bb)(BOOL);<br>
				BOOL (AFX_MSG_CALL CWnd::*pfn_bWww)(CWnd*, UINT, UINT);<br>
				BOOL (AFX_MSG_CALL CWnd::*pfn_bHELPINFO)(HELPINFO*);<br>
				BOOL (AFX_MSG_CALL CWnd::*pfn_bWCDS)(CWnd*, COPYDATASTRUCT*);<br>
				HBRUSH (AFX_MSG_CALL CWnd::*pfn_hDWw)(CDC*, CWnd*, UINT);<br>
				HBRUSH (AFX_MSG_CALL CWnd::*pfn_hDw)(CDC*, UINT);<br>
				int (AFX_MSG_CALL CWnd::*pfn_iwWw)(UINT, CWnd*, UINT);<br>
				int (AFX_MSG_CALL CWnd::*pfn_iww)(UINT, UINT);<br>
				int (AFX_MSG_CALL CWnd::*pfn_iWww)(CWnd*, UINT, UINT);<br>
				int (AFX_MSG_CALL CWnd::*pfn_is)(LPTSTR);<br>
				LRESULT (AFX_MSG_CALL CWnd::*pfn_lwl)(WPARAM, LPARAM);<br>
				LRESULT (AFX_MSG_CALL CWnd::*pfn_lwwM)(UINT, UINT, CMenu*);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vv)(void);<br>
				<br>
				void (AFX_MSG_CALL CWnd::*pfn_vw)(UINT);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vww)(UINT, UINT);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vvii)(int, int);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vwww)(UINT, UINT, UINT);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vwii)(UINT, int, int);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vwl)(WPARAM, LPARAM);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vbWW)(BOOL, CWnd*, CWnd*);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vD)(CDC*);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vM)(CMenu*);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vMwb)(CMenu*, UINT, BOOL);<br>
				<br>
				void (AFX_MSG_CALL CWnd::*pfn_vW)(CWnd*);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vWww)(CWnd*, UINT, UINT);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vWp)(CWnd*, CPoint);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vWh)(CWnd*, HANDLE);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vwW)(UINT, CWnd*);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vwWb)(UINT, CWnd*, BOOL);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vwwW)(UINT, UINT, CWnd*);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vwwx)(UINT, UINT);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vs)(LPTSTR);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vOWNER)(int, LPTSTR); // force 
				return TRUE<br>
				int (AFX_MSG_CALL CWnd::*pfn_iis)(int, LPTSTR);<br>
				UINT (AFX_MSG_CALL CWnd::*pfn_wp)(CPoint);<br>
				UINT (AFX_MSG_CALL CWnd::*pfn_wv)(void);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vPOS)(WINDOWPOS*);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vCALC)(BOOL, NCCALCSIZE_PARAMS*);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vwp)(UINT, CPoint);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vwwh)(UINT, UINT, HANDLE);<br>
				BOOL (AFX_MSG_CALL CWnd::*pfn_bwsp)(UINT, short, CPoint);<br>
				void (AFX_MSG_CALL CWnd::*pfn_vws)(UINT, LPCTSTR);<br>
				};</td>
			</tr>
		</table>
		mmf.pfn = lpEntry-&gt;pfn;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		// if we've got WM_SETTINGCHANGE / WM_WININICHANGE, we need to<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		// decide if we're going to call OnWinIniChange() or OnSettingChange()<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		int nSig;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		nSig = lpEntry-&gt;nSig;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		if (lpEntry-&gt;nID == WM_SETTINGCHANGE)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		DWORD dwVersion = GetVersion();<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (LOBYTE(LOWORD(dwVersion)) &gt;= 4)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		nSig = AfxSig_vws;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		else<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		nSig = AfxSig_vs;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		switch (nSig)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		default:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		ASSERT(FALSE);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_bD:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_bD)(CDC::FromHandle((HDC)wParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_bb: // AfxSig_bb, AfxSig_bw, AfxSig_bh<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_bb)((BOOL)wParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_bWww: // really AfxSig_bWiw<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_bWww)(CWnd::FromHandle((HWND)wParam),<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(short)LOWORD(lParam), HIWORD(lParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_bWCDS:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_bWCDS)(CWnd::FromHandle((HWND)wParam),<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(COPYDATASTRUCT*)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_bHELPINFO:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_bHELPINFO)((HELPINFO*)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_hDWw:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// special case for OnCtlColor to avoid too many temporary objects<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		ASSERT(message == WM_CTLCOLOR);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		AFX_CTLCOLOR* pCtl = (AFX_CTLCOLOR*)lParam;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		CDC dcTemp; dcTemp.m_hDC = pCtl-&gt;hDC;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		CWnd wndTemp; wndTemp.m_hWnd = pCtl-&gt;hWnd;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		UINT nCtlType = pCtl-&gt;nCtlType;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// if not coming from a permanent window, use stack temporary<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		CWnd* pWnd = CWnd::FromHandlePermanent(wndTemp.m_hWnd);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (pWnd == NULL)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		#ifndef _AFX_NO_OCC_SUPPORT<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// determine the site of the OLE control if it is one<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		COleControlSite* pSite;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (m_pCtrlCont != NULL &amp;&amp; (pSite = (COleControlSite*)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		m_pCtrlCont-&gt;m_siteMap.GetValueAt(wndTemp.m_hWnd)) != NULL)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		wndTemp.m_pCtrlSite = pSite;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		#endif<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		pWnd = &amp;wndTemp;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		HBRUSH hbr = (this-&gt;*mmf.pfn_hDWw)(&amp;dcTemp, pWnd, nCtlType);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// fast detach of temporary objects<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		dcTemp.m_hDC = NULL;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		wndTemp.m_hWnd = NULL;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (LRESULT)hbr;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_hDw:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// special case for CtlColor to avoid too many temporary objects<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASSERT(message == WM_REFLECT_BASE+WM_CTLCOLOR);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		AFX_CTLCOLOR* pCtl = (AFX_CTLCOLOR*)lParam;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		CDC dcTemp; dcTemp.m_hDC = pCtl-&gt;hDC;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		UINT nCtlType = pCtl-&gt;nCtlType;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		HBRUSH hbr = (this-&gt;*mmf.pfn_hDw)(&amp;dcTemp, nCtlType);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// fast detach of temporary objects<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		dcTemp.m_hDC = NULL;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (LRESULT)hbr;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_iwWw:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_iwWw)(LOWORD(wParam),<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		CWnd::FromHandle((HWND)lParam), HIWORD(wParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_iww:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_iww)(LOWORD(wParam), HIWORD(wParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_iWww: // really AfxSig_iWiw<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_iWww)(CWnd::FromHandle((HWND)wParam),<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(short)LOWORD(lParam), HIWORD(lParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_is:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_is)((LPTSTR)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_lwl:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_lwl)(wParam, lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_lwwM:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_lwwM)((UINT)LOWORD(wParam),<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(UINT)HIWORD(wParam), (CMenu*)CMenu::FromHandle((HMENU)lParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vv:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vv)();<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vw: // AfxSig_vb, AfxSig_vh<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vw)(wParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vww:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vww)((UINT)wParam, (UINT)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vvii:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vvii)((short)LOWORD(lParam), (short)HIWORD(lParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vwww:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vwww)(wParam, LOWORD(lParam), HIWORD(lParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vwii:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vwii)(wParam, LOWORD(lParam), HIWORD(lParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vwl:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vwl)(wParam, lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vbWW:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vbWW)(m_hWnd == (HWND)lParam,<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		CWnd::FromHandle((HWND)lParam),<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		CWnd::FromHandle((HWND)wParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vD:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vD)(CDC::FromHandle((HDC)wParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vM:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vM)(CMenu::FromHandle((HMENU)wParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vMwb:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vMwb)(CMenu::FromHandle((HMENU)wParam),<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		LOWORD(lParam), (BOOL)HIWORD(lParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vW:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vW)(CWnd::FromHandle((HWND)wParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vW2:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vW)(CWnd::FromHandle((HWND)lParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vWww:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vWww)(CWnd::FromHandle((HWND)wParam), LOWORD(lParam),<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		HIWORD(lParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vWp:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		CPoint point((DWORD)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vWp)(CWnd::FromHandle((HWND)wParam), point);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vWh:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vWh)(CWnd::FromHandle((HWND)wParam),<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(HANDLE)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vwW:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vwW)(wParam, CWnd::FromHandle((HWND)lParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vwWb:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vwWb)((UINT)(LOWORD(wParam)),<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		CWnd::FromHandle((HWND)lParam), (BOOL)HIWORD(wParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vwwW:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vwwx:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		// special case for WM_VSCROLL and WM_HSCROLL<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		ASSERT(message == WM_VSCROLL || message == WM_HSCROLL ||<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		message == WM_VSCROLL+WM_REFLECT_BASE ||message==WM_HSCROLL<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +WM_REFLECT_BASE);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		int nScrollCode = (short)LOWORD(wParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		int nPos = (short)HIWORD(wParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (lpEntry-&gt;nSig == AfxSig_vwwW)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vwwW)(nScrollCode, nPos,<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		CWnd::FromHandle((HWND)lParam));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		else<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vwwx)(nScrollCode, nPos);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vs:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vs)((LPTSTR)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vws:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vws)((UINT) wParam, (LPCTSTR)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vOWNER:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vOWNER)((int)wParam, (LPTSTR)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = TRUE;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_iis:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_iis)((int)wParam, (LPTSTR)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_wp:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		CPoint point((DWORD)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_wp)(point);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_wv: // AfxSig_bv, AfxSig_wv<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_wv)();<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vCALC:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vCALC)((BOOL)wParam, (NCCALCSIZE_PARAMS*)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vPOS:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vPOS)((WINDOWPOS*)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vwwh:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vwwh)(LOWORD(wParam), HIWORD(wParam), (HANDLE)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vwp:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		{<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		CPoint point((DWORD)lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vwp)(wParam, point);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_vwSIZING:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		(this-&gt;*mmf.pfn_vwl)(wParam, lParam);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = TRUE;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		break;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		case AfxSig_bwsp:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_bwsp)(LOWORD(wParam), (short) HIWORD(wParam),<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		CPoint(LOWORD(lParam), HIWORD(lParam)));<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		if (!lResult)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		return FALSE;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;
		}<br>
		goto LReturnTrue;<br>
		<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		LDispatchRegistered: // for registered windows messages<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		ASSERT(message &gt;= 0xC000);<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		mmf.pfn = lpEntry-&gt;pfn;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		lResult = (this-&gt;*mmf.pfn_lwl)(wParam, lParam);<br>
		<br>
		LReturnTrue:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pResult != NULL)<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		*pResult = lResult;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		return TRUE;<br>
		}</td>
	</tr>
	<tr>
		<td>
		//位置:mfc\src\wincore.cpp<p>/////////////////////////////////////////////////////////////////////////////<br>
		// Routines for fast search of message maps<br>
		<br>
		const AFX_MSGMAP_ENTRY* AFXAPI<br>
		<b><a name="AfxFindMessageEntry">AfxFindMessageEntry</a></b>(const AFX_MSGMAP_ENTRY* lpEntry,<br>
		UINT nMsg, UINT nCode, UINT nID)<br>
		{<br>
		#if defined(_M_IX86) &amp;&amp; !defined(_AFX_PORTABLE)<br>
		// 32-bit Intel 386/486 version.<br>
		<br>
		ASSERT(offsetof(AFX_MSGMAP_ENTRY, nMessage) == 0);<br>
		ASSERT(offsetof(AFX_MSGMAP_ENTRY, nCode) == 4);<br>
		ASSERT(offsetof(AFX_MSGMAP_ENTRY, nID) == 8);<br>
		ASSERT(offsetof(AFX_MSGMAP_ENTRY, nLastID) == 12);<br>
		ASSERT(offsetof(AFX_MSGMAP_ENTRY, nSig) == 16);<br>
		<br>
		_asm<br>
		{<br>
		MOV EBX,lpEntry<br>
		MOV EAX,nMsg<br>
		MOV EDX,nCode<br>
		MOV ECX,nID<br>
		__loop:<br>
		CMP DWORD PTR [EBX+16],0 ; nSig (0 =&gt; end)<br>
		JZ __failed<br>
		CMP EAX,DWORD PTR [EBX] ; nMessage<br>
		JE __found_message<br>
		__next:<br>
		ADD EBX,SIZE AFX_MSGMAP_ENTRY<br>
		JMP short __loop<br>
		__found_message:<br>
		CMP EDX,DWORD PTR [EBX+4] ; nCode<br>
		JNE __next<br>
		// message and code good so far<br>
		// check the ID<br>
		CMP ECX,DWORD PTR [EBX+8] ; nID<br>
		JB __next<br>
		CMP ECX,DWORD PTR [EBX+12] ; nLastID<br>
		JA __next<br>
		// found a match<br>
		MOV lpEntry,EBX ; return EBX<br>
		JMP short __end<br>
		__failed:<br>
		XOR EAX,EAX ; return NULL<br>
		MOV lpEntry,EAX<br>
		__end:<br>
		}<br>
		return lpEntry;<br>
		#else // _AFX_PORTABLE<br>
		// C version of search routine<br>
		while (lpEntry-&gt;nSig != AfxSig_end)<br>
		{<br>
		if (lpEntry-&gt;nMessage == nMsg &amp;&amp; lpEntry-&gt;nCode == nCode &amp;&amp;<br>
		nID &gt;= lpEntry-&gt;nID &amp;&amp; nID &lt;= lpEntry-&gt;nLastID)<br>
		{<br>
		return lpEntry;<br>
		}<br>
		lpEntry++;<br>
		}<br>
		return NULL; // not found<br>
		#endif // _AFX_PORTABLE<br>
		}</p></td>
	</tr>
	<tr>
		<td>
		/////////////////////////////////////////////////////////////////////////////<br>
		// Cache of most recently sent messages<br>
		<br>
		#ifndef iHashMax<br>
		// iHashMax must be a power of two<br>
		#define iHashMax 512<br>
		#endif<br>
		<br>
		struct <b><a name="AFX_MSG_CACHE">AFX_MSG_CACHE</a></b><br>
		{<br>
		UINT nMsg;<br>
		const AFX_MSGMAP_ENTRY* lpEntry;<br>
		const AFX_MSGMAP* pMessageMap;<br>
		};<br>
		<br>
		AFX_MSG_CACHE _afxMsgCache[iHashMax];<br>
		<br>
		void AFXAPI <b><a name="AfxResetMsgCache">AfxResetMsgCache</a></b>()<br>
		{<br>
		memset(_afxMsgCache, 0, sizeof(_afxMsgCache));<br>
		}</td>
	</tr>
	<tr>
		<td>
		BOOL <a name="CWnd::OnCommand">CWnd::OnCommand</a>(WPARAM wParam, LPARAM 
		lParam)<br>
		// return TRUE if command invocation was attempted<br>
		{<br>
		UINT nID = LOWORD(wParam);<br>
		HWND hWndCtrl = (HWND)lParam;<br>
		int nCode = HIWORD(wParam);<br>
		<br>
		// default routing for command messages (through closure table)<br>
		<br>
		if (hWndCtrl == NULL)<br>
		{<br>
		// zero IDs for normal commands are not allowed<br>
		if (nID == 0)<br>
		return FALSE;<br>
		<br>
		// make sure command has not become disabled before routing<br>
		CTestCmdUI state;<br>
		state.m_nID = nID;<br>
		OnCmdMsg(nID, CN_UPDATE_COMMAND_UI, &amp;state, NULL);<br>
		if (!state.m_bEnabled)<br>
		{<br>
		TRACE1(&quot;Warning: not executing disabled command %d\n&quot;, nID);<br>
		return TRUE;<br>
		}<br>
		<br>
		// menu or accelerator<br>
		nCode = CN_COMMAND;<br>
		}<br>
		else<br>
		{<br>
		// control notification<br>
		ASSERT(nID == 0 || ::IsWindow(hWndCtrl));<br>
		<br>
		if (_afxThreadState-&gt;m_hLockoutNotifyWindow == m_hWnd)<br>
		return TRUE; // locked out - ignore control notification<br>
		<br>
		// reflect notification to child window control<br>
		if (ReflectLastMsg(hWndCtrl))<br>
		return TRUE; // eaten by child<br>
		<br>
		// zero IDs for normal commands are not allowed<br>
		if (nID == 0)<br>
		return FALSE;<br>
		}<br>
		<br>
		#ifdef _DEBUG<br>
		if (nCode &lt; 0 &amp;&amp; nCode != (int)0x8000)<br>
		TRACE1(&quot;Implementation Warning: control notification = $%X.\n&quot;,<br>
		nCode);<br>
		#endif<br>
		<br>
		return OnCmdMsg(nID, nCode, NULL, NULL);<br>
		}</td>
	</tr>
	<tr>
		<td>
		BOOL <a name="CWnd::OnNotify">CWnd::OnNotify</a>(WPARAM, LPARAM lParam, 
		LRESULT* pResult)<br>
		{<br>
		ASSERT(pResult != NULL);<br>
		NMHDR* pNMHDR = (NMHDR*)lParam;<br>
		HWND hWndCtrl = pNMHDR-&gt;hwndFrom;<br>
		<br>
		// get the child ID from the window itself<br>
		UINT nID = _AfxGetDlgCtrlID(hWndCtrl);<br>
		int nCode = pNMHDR-&gt;code;<br>
		<br>
		ASSERT(hWndCtrl != NULL);<br>
		ASSERT(::IsWindow(hWndCtrl));<br>
		<br>
		if (_afxThreadState-&gt;m_hLockoutNotifyWindow == m_hWnd)<br>
		return TRUE; // locked out - ignore control notification<br>
		<br>
		// reflect notification to child window control<br>
		if (ReflectLastMsg(hWndCtrl, pResult))<br>
		return TRUE; // eaten by child<br>
		<br>
		AFX_NOTIFY notify;<br>
		notify.pResult = pResult;<br>
		notify.pNMHDR = pNMHDR;<br>
		return OnCmdMsg(nID, MAKELONG(nCode, WM_NOTIFY), &amp;notify, NULL);<br>
		}</td>
	</tr>
</table>
<p></p>
<table border="1" width="100%" class="TableStyle" style ="display:none" id ="afxdispatchcmdmsg">
	<tr>
		<td>// Overridables<br>
		// route and dispatch standard command message types<br>
		// (more sophisticated than OnCommand)<br>
		virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		AFX_CMDHANDLERINFO* pHandlerInfo);<br>
　<p>BOOL CCmdTarget::<b>OnCmdMsg</b>(UINT nID, int nCode, void* pExtra,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		AFX_CMDHANDLERINFO* pHandlerInfo)<br>
		{<br>
		#ifndef _AFX_NO_OCC_SUPPORT<br>
		// OLE control events are a special case<br>
		if (nCode == CN_EVENT)<br>
		{<br>
&nbsp;&nbsp;&nbsp; ASSERT(afxOccManager != NULL);<br>
&nbsp;&nbsp;&nbsp; return afxOccManager-&gt;OnEvent(this, nID, (AFX_EVENT*)pExtra, 
		pHandlerInfo);<br>
		}<br>
		#endif // !_AFX_NO_OCC_SUPPORT<br>
		<br>
		// determine the message number and code (packed into nCode)<br>
		const AFX_MSGMAP* pMessageMap;<br>
		const AFX_MSGMAP_ENTRY* lpEntry;<br>
		UINT nMsg = 0;<br>
		<br>
		#ifndef _AFX_NO_DOCOBJECT_SUPPORT<br>
		if (nCode == CN_OLECOMMAND)<br>
		{<br>
		BOOL bResult = FALSE;<br>
		<br>
		const AFX_OLECMDMAP* pOleCommandMap;<br>
		const AFX_OLECMDMAP_ENTRY* pEntry;<br>
		<br>
		COleCmdUI* pUI = (COleCmdUI*) pExtra;<br>
		const GUID* pguidCmdGroup = pUI-&gt;m_pguidCmdGroup;<br>
		<br>
		#ifdef _AFXDLL<br>
		for (pOleCommandMap = GetCommandMap(); pOleCommandMap != NULL &amp;&amp; 
		!bResult;<br>
		pOleCommandMap = pOleCommandMap-&gt;pfnGetBaseMap())<br>
		#else<br>
		for (pOleCommandMap = GetCommandMap(); pOleCommandMap != NULL &amp;&amp; 
		!bResult;<br>
		pOleCommandMap = pOleCommandMap-&gt;pBaseMap)<br>
		#endif<br>
		{<br>
		for (pEntry = pOleCommandMap-&gt;lpEntries;<br>
		pEntry-&gt;cmdID != 0 &amp;&amp; pEntry-&gt;nID != 0 &amp;&amp; !bResult;<br>
		pEntry++)<br>
		{<br>
		if (nID == pEntry-&gt;cmdID &amp;&amp;<br>
		IsEqualNULLGuid(pguidCmdGroup, pEntry-&gt;pguid))<br>
		{<br>
		pUI-&gt;m_nID = pEntry-&gt;nID;<br>
		bResult = TRUE;<br>
		}<br>
		}<br>
		}<br>
		<br>
		return bResult;<br>
		}<br>
		#endif<br>
		<br>
		if (nCode != CN_UPDATE_COMMAND_UI)<br>
		{<br>
		nMsg = HIWORD(nCode);<br>
		nCode = LOWORD(nCode);<br>
		}<br>
		<br>
		// for backward compatibility HIWORD(nCode)==0 is WM_COMMAND<br>
		if (nMsg == 0)<br>
		nMsg = WM_COMMAND;<br>
		<br>
		// look through message map to see if it applies to us<br>
		#ifdef _AFXDLL<br>
		for (pMessageMap = GetMessageMap(); pMessageMap != NULL;<br>
		pMessageMap = (*pMessageMap-&gt;pfnGetBaseMap)())<br>
		#else<br>
		for (pMessageMap = GetMessageMap(); pMessageMap != NULL;<br>
		pMessageMap = pMessageMap-&gt;pBaseMap)<br>
		#endif<br>
		{<br>
		// Note: catches BEGIN_MESSAGE_MAP(CMyClass, CMyClass)!<br>
		#ifdef _AFXDLL<br>
		ASSERT(pMessageMap != (*pMessageMap-&gt;pfnGetBaseMap)());<br>
		#else<br>
		ASSERT(pMessageMap != pMessageMap-&gt;pBaseMap);<br>
		#endif<br>
		<br>
		lpEntry = AfxFindMessageEntry(pMessageMap-&gt;lpEntries, nMsg, nCode, nID);<br>
		if (lpEntry != NULL)<br>
		{<br>
		// found it<br>
		#ifdef _DEBUG<br>
		if (afxTraceFlags &amp; traceCmdRouting)<br>
		{<br>
		if (nCode == CN_COMMAND)<br>
		{<br>
		TRACE2(&quot;SENDING command id 0x%04X to %hs target.\n&quot;, nID,<br>
		GetRuntimeClass()-&gt;m_lpszClassName);<br>
		}<br>
		else if (nCode &gt; CN_COMMAND)<br>
		{<br>
		if (afxTraceFlags &amp; traceWinMsg)<br>
		{<br>
		TRACE3(&quot;SENDING control notification %d from control id 0x%04X to %hs 
		window.\n&quot;,<br>
		nCode, nID, GetRuntimeClass()-&gt;m_lpszClassName);<br>
		}<br>
		}<br>
		}<br>
		#endif //_DEBUG<br>
		return <a href="#_AfxDispatchCmdMsg">_AfxDispatchCmdMsg</a>(this, nID, 
		nCode,<br>
		lpEntry-&gt;pfn, pExtra, lpEntry-&gt;nSig, pHandlerInfo);<br>
		}<br>
		}<br>
		return FALSE; // not handled<br>
		}</td>
	</tr>
	<tr>
		<td>//位置:mfc\src\cmdtarg.cpp<p>
		/////////////////////////////////////////////////////////////////////////////<br>
		// CCmdTarget windows message dispatching<br>
		<br>
		AFX_STATIC BOOL AFXAPI <b><a name="_AfxDispatchCmdMsg">
		_AfxDispatchCmdMsg</a></b>(CCmdTarget* pTarget, UINT nID, int nCode,<br>
		AFX_PMSG pfn, void* pExtra, UINT nSig, AFX_CMDHANDLERINFO* pHandlerInfo)<br>
		// return TRUE to stop routing<br>
		{<br>
		ASSERT_VALID(pTarget);<br>
		UNUSED(nCode); // unused in release builds<br>
		<br>
		union MessageMapFunctions mmf;<br>
		mmf.pfn = pfn;<br>
		BOOL bResult = TRUE; // default is ok<br>
		<br>
		if (pHandlerInfo != NULL)<br>
		{<br>
		// just fill in the information, don't do it<br>
		pHandlerInfo-&gt;pTarget = pTarget;<br>
		pHandlerInfo-&gt;pmf = mmf.pfn;<br>
		return TRUE;<br>
		}<br>
		<br>
		switch (nSig)<br>
		{<br>
		case AfxSig_vv:<br>
		// normal command or control notification<br>
		ASSERT(CN_COMMAND == 0); // CN_COMMAND same as BN_CLICKED<br>
		ASSERT(pExtra == NULL);<br>
		(pTarget-&gt;*mmf.pfn_COMMAND)();<br>
		break;<br>
		<br>
		case AfxSig_bv:<br>
		// normal command or control notification<br>
		ASSERT(CN_COMMAND == 0); // CN_COMMAND same as BN_CLICKED<br>
		ASSERT(pExtra == NULL);<br>
		bResult = (pTarget-&gt;*mmf.pfn_bCOMMAND)();<br>
		break;<br>
		<br>
		case AfxSig_vw:<br>
		// normal command or control notification in a range<br>
		ASSERT(CN_COMMAND == 0); // CN_COMMAND same as BN_CLICKED<br>
		ASSERT(pExtra == NULL);<br>
		(pTarget-&gt;*mmf.pfn_COMMAND_RANGE)(nID);<br>
		break;<br>
		<br>
		case AfxSig_bw:<br>
		// extended command (passed ID, returns bContinue)<br>
		ASSERT(pExtra == NULL);<br>
		bResult = (pTarget-&gt;*mmf.pfn_COMMAND_EX)(nID);<br>
		break;<br>
		<br>
		case AfxSig_vNMHDRpl:<br>
		{<br>
		AFX_NOTIFY* pNotify = (AFX_NOTIFY*)pExtra;<br>
		ASSERT(pNotify != NULL);<br>
		ASSERT(pNotify-&gt;pResult != NULL);<br>
		ASSERT(pNotify-&gt;pNMHDR != NULL);<br>
		(pTarget-&gt;*mmf.pfn_NOTIFY)(pNotify-&gt;pNMHDR, pNotify-&gt;pResult);<br>
		}<br>
		break;<br>
		case AfxSig_bNMHDRpl:<br>
		{<br>
		AFX_NOTIFY* pNotify = (AFX_NOTIFY*)pExtra;<br>
		ASSERT(pNotify != NULL);<br>
		ASSERT(pNotify-&gt;pResult != NULL);<br>
		ASSERT(pNotify-&gt;pNMHDR != NULL);<br>
		bResult = (pTarget-&gt;*mmf.pfn_bNOTIFY)(pNotify-&gt;pNMHDR, 
		pNotify-&gt;pResult);<br>
		}<br>
		break;<br>
		case AfxSig_vwNMHDRpl:<br>
		{<br>
		AFX_NOTIFY* pNotify = (AFX_NOTIFY*)pExtra;<br>
		ASSERT(pNotify != NULL);<br>
		ASSERT(pNotify-&gt;pResult != NULL);<br>
		ASSERT(pNotify-&gt;pNMHDR != NULL);<br>
		(pTarget-&gt;*mmf.pfn_NOTIFY_RANGE)(nID, pNotify-&gt;pNMHDR,<br>
		pNotify-&gt;pResult);<br>
		}<br>
		break;<br>
		case AfxSig_bwNMHDRpl:<br>
		{<br>
		AFX_NOTIFY* pNotify = (AFX_NOTIFY*)pExtra;<br>
		ASSERT(pNotify != NULL);<br>
		ASSERT(pNotify-&gt;pResult != NULL);<br>
		ASSERT(pNotify-&gt;pNMHDR != NULL);<br>
		bResult = (pTarget-&gt;*mmf.pfn_NOTIFY_EX)(nID, pNotify-&gt;pNMHDR,<br>
		pNotify-&gt;pResult);<br>
		}<br>
		break;<br>
		case AfxSig_cmdui:<br>
		{<br>
		// ON_UPDATE_COMMAND_UI or ON_UPDATE_COMMAND_UI_REFLECT case<br>
		ASSERT(CN_UPDATE_COMMAND_UI == (UINT)-1);<br>
		ASSERT(nCode == CN_UPDATE_COMMAND_UI || nCode == 0xFFFF);<br>
		ASSERT(pExtra != NULL);<br>
		CCmdUI* pCmdUI = (CCmdUI*)pExtra;<br>
		ASSERT(!pCmdUI-&gt;m_bContinueRouting); // idle - not set<br>
		(pTarget-&gt;*mmf.pfn_UPDATE_COMMAND_UI)(pCmdUI);<br>
		bResult = !pCmdUI-&gt;m_bContinueRouting;<br>
		pCmdUI-&gt;m_bContinueRouting = FALSE; // go back to idle<br>
		}<br>
		break;<br>
		<br>
		case AfxSig_cmduiw:<br>
		{<br>
		// ON_UPDATE_COMMAND_UI case<br>
		ASSERT(nCode == CN_UPDATE_COMMAND_UI);<br>
		ASSERT(pExtra != NULL);<br>
		CCmdUI* pCmdUI = (CCmdUI*)pExtra;<br>
		ASSERT(pCmdUI-&gt;m_nID == nID); // sanity assert<br>
		ASSERT(!pCmdUI-&gt;m_bContinueRouting); // idle - not set<br>
		(pTarget-&gt;*mmf.pfn_UPDATE_COMMAND_UI_RANGE)(pCmdUI, nID);<br>
		bResult = !pCmdUI-&gt;m_bContinueRouting;<br>
		pCmdUI-&gt;m_bContinueRouting = FALSE; // go back to idle<br>
		}<br>
		break;<br>
		<br>
		// general extensibility hooks<br>
		case AfxSig_vpv:<br>
		(pTarget-&gt;*mmf.pfn_OTHER)(pExtra);<br>
		break;<br>
		case AfxSig_bpv:<br>
		bResult = (pTarget-&gt;*mmf.pfn_OTHER_EX)(pExtra);<br>
		break;<br>
		<br>
		default: // illegal<br>
		ASSERT(FALSE);<br>
		return 0;<br>
		}<br>
		return bResult;<br>
		}</td>
	</tr>
	</table>
<p>程序入口函数：<span class ="ShowLink" onclick ="Call Show(afxwndmain)">AfxWinMain</span></p>
<table border="1" width="100%" class="TableStyle" id="afxwndmain" style ="display:none">
	<tr>
		<td>
		/////////////////////////////////////////////////////////////////////////////<br>
		// Standard WinMain implementation<br>
		// Can be replaced as long as 'AfxWinInit' is called first<br>
		<br>
		int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,<br>
		LPTSTR lpCmdLine, int nCmdShow)<br>
		{<br>
		ASSERT(hPrevInstance == NULL);<br>
		<br>
		int nReturnCode = -1;<br>
		CWinThread* pThread = AfxGetThread();<br>
		CWinApp* pApp = AfxGetApp();<br>
		<br>
		// AFX internal initialization<br>
		if (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow))<br>
		goto InitFailure;<br>
		<br>
		// App global initializations (rare)<br>
		if (pApp != NULL &amp;&amp; !pApp-&gt;InitApplication())<br>
		goto InitFailure;<br>
		<br>
		// Perform specific initializations<br>
		if (!pThread-&gt;InitInstance())<br>
		{<br>
		if (pThread-&gt;m_pMainWnd != NULL)<br>
		{<br>
		TRACE0(&quot;Warning: Destroying non-NULL m_pMainWnd\n&quot;);<br>
		pThread-&gt;m_pMainWnd-&gt;DestroyWindow();<br>
		}<br>
		nReturnCode = pThread-&gt;ExitInstance();<br>
		goto InitFailure;<br>
		}<br>
		nReturnCode = pThread-&gt;Run();<br>
		<br>
		InitFailure:<br>
		#ifdef _DEBUG<br>
		// Check for missing AfxLockTempMap calls<br>
		if (AfxGetModuleThreadState()-&gt;m_nTempMapLock != 0)<br>
		{<br>
		TRACE1(&quot;Warning: Temp map lock count non-zero (%ld).\n&quot;,<br>
		AfxGetModuleThreadState()-&gt;m_nTempMapLock);<br>
		}<br>
		AfxLockTempMaps();<br>
		AfxUnlockTempMaps(-1);<br>
		#endif<br>
		<br>
		AfxWinTerm();<br>
		return nReturnCode;<br>
		}</td>
	</tr>
</table>
<p><b><font size="4">建立MFC消息</font></b></p>
<p><font size="4">一、在头文件中定义消息处理函数和DELARE_MESSAGE_MAP宏。</font></p>
<p><font size="4">二、在接口文件中加入BEGIN_MESSAGE_MAP(CLASSE, 
BASECLASSE)和END_MESSAGE_MAP(),在它们中间加入消息映像。</font></p>
<p><font size="4">三、消息映像：</font></p>
<p><font size="4">1、菜单、工具条消息：<br>
&nbsp;&nbsp; <a href="#ON_COMMAND">ON_COMMAND</a>(菜单、工具条的 ID, 消息处理函数)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
（第五种格式）<br>
&nbsp;&nbsp; <a href="#ON_UPDATE_COMMAND_UI">ON_UPDATE_COMMAND_UI</a>(菜单、工具条的 
ID, 消息处理函数)&nbsp;&nbsp; <br>
&nbsp; （第一种格式，格式中的第二个值为</font>CN_UPDATE_COMMAND_UI<font size="4">（-1））</font></p>
<p><font size="4">2、Windows消息：<br>
&nbsp;&nbsp; <a href="#Message_map_tables_for_Windows_messages">ON_Windows消息</a>（）</font></p>
<p><font size="4">3、传统控件通知消息：（第一种格式）<br>
&nbsp;&nbsp; <a href="#Message_map_tables_for_Control_Notification_messages">
ON_通知消息</a>（控件的 ID， 消息处理函数）<br>
&nbsp;&nbsp; 把多个ID连续的控件发出的相同消息映射到时同一个消息处理函数上：<br>
&nbsp;&nbsp; <a href="#ON_CONTROL_RANGE">ON_CONTROL_RANGE</a>(通知消息，连续控件ID中的头一个的ID，最后一个的ID，消息处理函数）</font></p>
<p><font size="4">4、Win32控件消息：（第三种格式）<br>
&nbsp;&nbsp; <a href="#ON_NOTIFY">ON_NOTIIFY</a>(通知消息码，控件 ID，消息处理函数）<br>
&nbsp;&nbsp; 把多个ID连续的控件发出的相同消息映射到时同一个消息处理函数上：<br>
&nbsp;&nbsp; <a href="#ON_NOTIFY_RANGE">ON_NOTIFY_RANGE</a>(通知消息码，连续控件ID中的头一个的ID，最后一个的ID，消息处理函数）<br>
&nbsp;&nbsp; 
Win32控件采用新的WM_NOTIFY消息来实现新的控件的消息通知机制，在该消息的wPara中含有控件的ID，lParam中则有一个指针，指向一个结构。这个结构要么是NMHDR，要么是一个以NMHDR作为第一个成员的扩充结构。<br>
&nbsp;&nbsp; typedef struct tabNMHDR{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND 
hwndFrom;//控件窗口的句柄<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT idFrom;&nbsp; 
//控件的ID<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT code;&nbsp;&nbsp;&nbsp; 
//控件的通知消息<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } NMHDR;<br>
&nbsp;&nbsp; 扩充结构：<br>
&nbsp;&nbsp; typedef struct tagLV_KEYDOWN{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WMHDR 
hdr;//NMHDR作为第一个成员<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD&nbsp; wrKey;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT flags;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }LV_KEYDOWN;&nbsp;
</font></p>
<p><font size="4">5、用户自定义消息：(第七种格式）<br>
&nbsp;&nbsp; <a href="#ON_MESSAGE">ON_MESSAGE</a>(用户自定义消息, 消息处理函数)</font></p>
<p><font size="4">6、注册消息：（第八种格式）<br>
&nbsp;&nbsp; </font><a href="#ON_REGISTERED_MESSAGE">ON_REGISTERED_MESSAGE</a>(消息值, 
消息<font size="4">处理</font>函数)</p>
<p>7、线程消息<br>
&nbsp;&nbsp; <a href="#ON_THREAD_MESSAGE">ON_THREAD_MESSAGE</a>(消息值, 消息处理函数)</p>

<span class="ShowLink" onclick="Call Show(AFXMSG_)" >AFXMSG_.H</span>
<table border="1" width="100%" id="AFXMSG_" style ="display:none" class="TableStyle">
	<tr>
		<td>//AFXMSG_.H<br>
		// This is a part of the Microsoft Foundation Classes C++ library.
		// Copyright (C) 1992-1998 Microsoft Corporation<br>
		// All rights reserved.<br>
		//<br>
		// This source code is only intended as a supplement to the<br>
		// Microsoft Foundation Classes Reference and related<br>
		// electronic documentation provided with the library.<br>
		// See these sources for detailed information regarding the<br>
		// Microsoft Foundation Classes product.<br>
		<br>
		// Do not include this file directly (included by AFXWIN.H)<br>
		<br>
		/////////////////////////////////////////////////////////////////////////////<br>
		<br>
		// Entries in a message map (a 'AFX_MSGMAP_ENTRY') table can be of 9 
		formats<br>
		//<br>
		// 1) control notification message (i.e. in response to WM_COMMAND)<br>
		// WM_COMMAND, nNotifyCode, nControlID, nControlID, signature type, 
		parameterless member function<br>
		// (eg: WM_COMMAND, LBN_SELCHANGE, IDC_LISTBOX, AfxSig_vv, ... )<br>
		// 2) control notification message range (i.e. in response to 
		WM_COMMAND)<br>
		// WM_COMMAND, nNotifyCode, nControlIDFirst, nControlIDLast, signature 
		type, parameterless member function<br>
		// (eg: WM_COMMAND, LBN_SELCHANGE, IDC_LISTBOX1, IDC_LISTBOX5, 
		AfxSig_vw, ... )<br>
		// 3) WM_NOTIFY notification<br>
		// WM_NOTIFY, nNotifyCode, nControlID, nControlID, signature type, ...)<br>
		// 3) Update Command UI<br>
		// -1, 0, nControlID, 0, signature Unknown, parameterless member 
		function<br>
		// 4) Update Command UI Range<br>
		// -1, 0, nControlIDFirst, nControlIDLast, signature Unknown, 
		parameterless member function<br>
		// 5) menu/accelerator notification message (i.e. special case of first 
		format)<br>
		// WM_COMMAND, 0, nID, 0, signature type, parameterless member function<br>
		// (eg: WM_COMMAND, 0, IDM_FILESAVE, 0, AfxSig_vv, ... )<br>
		// 6) menu/accelerator notification message range<br>
		// WM_COMMAND, 0, nIDFirst, nIDLast, signature type, parameterless 
		member function<br>
		// (eg: WM_COMMAND, 0, IDM_FILE_MRU1, IDM_FILE_MRU4, AfxSig_vw, ... )<br>
		// 7) constant windows message<br>
		// nMessage, 0, 0, 0, signature type, member function<br>
		// (eg: WM_PAINT, 0, ...)<br>
		// 8) variable windows message (using RegisterWindowMessage)<br>
		// 0xC000, 0, 0, 0, &amp;nMessage, special member function<br>
		//<br>
		// The end of the message map is marked with a special value<br>
		// 0, 0, AfxSig_end, 0<br>
		/////////////////////////////////////////////////////////////////////////////<br>
		<br>
		enum AfxSig<br>
		{<br>
		AfxSig_end = 0, // [marks end of message map]<br>
		<br>
		AfxSig_bD, // BOOL (CDC*)<br>
		AfxSig_bb, // BOOL (BOOL)<br>
		AfxSig_bWww, // BOOL (CWnd*, UINT, UINT)<br>
		AfxSig_hDWw, // HBRUSH (CDC*, CWnd*, UINT)<br>
		AfxSig_hDw, // HBRUSH (CDC*, UINT)<br>
		AfxSig_iwWw, // int (UINT, CWnd*, UINT)<br>
		AfxSig_iww, // int (UINT, UINT)<br>
		AfxSig_iWww, // int (CWnd*, UINT, UINT)<br>
		AfxSig_is, // int (LPTSTR)<br>
		AfxSig_lwl, // LRESULT (WPARAM, LPARAM)<br>
		AfxSig_lwwM, // LRESULT (UINT, UINT, CMenu*)<br>
		AfxSig_vv, // void (void)<br>
		<br>
		AfxSig_vw, // void (UINT)<br>
		AfxSig_vww, // void (UINT, UINT)<br>
		AfxSig_vvii, // void (int, int) // wParam is ignored<br>
		AfxSig_vwww, // void (UINT, UINT, UINT)<br>
		AfxSig_vwii, // void (UINT, int, int)<br>
		AfxSig_vwl, // void (UINT, LPARAM)<br>
		AfxSig_vbWW, // void (BOOL, CWnd*, CWnd*)<br>
		AfxSig_vD, // void (CDC*)<br>
		AfxSig_vM, // void (CMenu*)<br>
		AfxSig_vMwb, // void (CMenu*, UINT, BOOL)<br>
		<br>
		AfxSig_vW, // void (CWnd*)<br>
		AfxSig_vWww, // void (CWnd*, UINT, UINT)<br>
		AfxSig_vWp, // void (CWnd*, CPoint)<br>
		AfxSig_vWh, // void (CWnd*, HANDLE)<br>
		AfxSig_vwW, // void (UINT, CWnd*)<br>
		AfxSig_vwWb, // void (UINT, CWnd*, BOOL)<br>
		AfxSig_vwwW, // void (UINT, UINT, CWnd*)<br>
		AfxSig_vwwx, // void (UINT, UINT)<br>
		AfxSig_vs, // void (LPTSTR)<br>
		AfxSig_vOWNER, // void (int, LPTSTR), force return TRUE<br>
		AfxSig_iis, // int (int, LPTSTR)<br>
		AfxSig_wp, // UINT (CPoint)<br>
		AfxSig_wv, // UINT (void)<br>
		AfxSig_vPOS, // void (WINDOWPOS*)<br>
		AfxSig_vCALC, // void (BOOL, NCCALCSIZE_PARAMS*)<br>
		AfxSig_vNMHDRpl, // void (NMHDR*, LRESULT*)<br>
		AfxSig_bNMHDRpl, // BOOL (NMHDR*, LRESULT*)<br>
		AfxSig_vwNMHDRpl, // void (UINT, NMHDR*, LRESULT*)<br>
		AfxSig_bwNMHDRpl, // BOOL (UINT, NMHDR*, LRESULT*)<br>
		AfxSig_bHELPINFO, // BOOL (HELPINFO*)<br>
		AfxSig_vwSIZING, // void (UINT, LPRECT) -- return TRUE<br>
		<br>
		// signatures specific to CCmdTarget<br>
		AfxSig_cmdui, // void (CCmdUI*)<br>
		AfxSig_cmduiw, // void (CCmdUI*, UINT)<br>
		AfxSig_vpv, // void (void*)<br>
		AfxSig_bpv, // BOOL (void*)<br>
		<br>
		// Other aliases (based on implementation)<br>
		AfxSig_vwwh, // void (UINT, UINT, HANDLE)<br>
		AfxSig_vwp, // void (UINT, CPoint)<br>
		AfxSig_bw = AfxSig_bb, // BOOL (UINT)<br>
		AfxSig_bh = AfxSig_bb, // BOOL (HANDLE)<br>
		AfxSig_iw = AfxSig_bb, // int (UINT)<br>
		AfxSig_ww = AfxSig_bb, // UINT (UINT)<br>
		AfxSig_bv = AfxSig_wv, // BOOL (void)<br>
		AfxSig_hv = AfxSig_wv, // HANDLE (void)<br>
		AfxSig_vb = AfxSig_vw, // void (BOOL)<br>
		AfxSig_vbh = AfxSig_vww, // void (BOOL, HANDLE)<br>
		AfxSig_vbw = AfxSig_vww, // void (BOOL, UINT)<br>
		AfxSig_vhh = AfxSig_vww, // void (HANDLE, HANDLE)<br>
		AfxSig_vh = AfxSig_vw, // void (HANDLE)<br>
		AfxSig_viSS = AfxSig_vwl, // void (int, STYLESTRUCT*)<br>
		AfxSig_bwl = AfxSig_lwl,<br>
		AfxSig_vwMOVING = AfxSig_vwSIZING, // void (UINT, LPRECT) -- return TRUE<br>
		<br>
		AfxSig_vW2, // void (CWnd*) (CWnd* comes from lParam)<br>
		AfxSig_bWCDS, // BOOL (CWnd*, COPYDATASTRUCT*)<br>
		AfxSig_bwsp, // BOOL (UINT, short, CPoint)<br>
		AfxSig_vws,<br>
		};<br>
		<br>
		/////////////////////////////////////////////////////////////////////////////<br>
		// Command notifications for CCmdTarget notifications<br>
		<br>
		#define CN_COMMAND 0 // void ()<br>
		#define CN_UPDATE_COMMAND_UI ((UINT)(-1)) // void (CCmdUI*)<br>
		#define CN_EVENT ((UINT)(-2)) // OLE event<br>
		#define CN_OLECOMMAND ((UINT)(-3)) // OLE document command<br>
		#define CN_OLE_UNREGISTER ((UINT)(-4)) // OLE unregister<br>
		// &gt; 0 are control notifications<br>
		// &lt; 0 are for MFC's use<br>
		<br>
		#define <a name="ON_COMMAND">ON_COMMAND</a>(id, memberFxn) \<br>
		{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)id, AfxSig_vv, 
		(AFX_PMSG)&amp;memberFxn },<br>
		// ON_COMMAND(id, OnFoo) is the same as<br>
		// ON_CONTROL(0, id, OnFoo) or ON_BN_CLICKED(0, id, OnFoo)<br>
		<br>
		#define <a name="ON_COMMAND_RANGE">ON_COMMAND_RANGE</a>(id, idLast, memberFxn) \<br>
		{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)idLast, AfxSig_vw, \<br>
		(AFX_PMSG)(void (AFX_MSG_CALL CCmdTarget::*)(UINT))&amp;memberFxn },<br>
		// ON_COMMAND_RANGE(id, idLast, OnFoo) is the same as<br>
		// ON_CONTROL_RANGE(0, id, idLast, OnFoo)<br>
		<br>
		#define ON_COMMAND_EX(id, memberFxn) \<br>
		{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)id, AfxSig_bw, \<br>
		(AFX_PMSG)(BOOL (AFX_MSG_CALL CCmdTarget::*)(UINT))&amp;memberFxn },<br>
		<br>
		#define ON_COMMAND_EX_RANGE(id, idLast, memberFxn) \<br>
		{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)idLast, AfxSig_bw, \<br>
		(AFX_PMSG)(BOOL (AFX_MSG_CALL CCmdTarget::*)(UINT))&amp;memberFxn },<br>
		<br>
		// update ui's are listed as WM_COMMAND's so they get routed like 
		commands<br>
		#define <a name="ON_UPDATE_COMMAND_UI">ON_UPDATE_COMMAND_UI</a>(id, memberFxn) \<br>
		{ WM_COMMAND, CN_UPDATE_COMMAND_UI, (WORD)id, (WORD)id, AfxSig_cmdui, \<br>
		(AFX_PMSG)(void (AFX_MSG_CALL CCmdTarget::*)(CCmdUI*))&amp;memberFxn },<br>
		<br>
		#define <a name="ON_UPDATE_COMMAND_UI_RANGE">ON_UPDATE_COMMAND_UI_RANGE</a>(id, idLast, memberFxn) \<br>
		{ WM_COMMAND, CN_UPDATE_COMMAND_UI, (WORD)id, (WORD)idLast, 
		AfxSig_cmdui, \<br>
		(AFX_PMSG)(void (AFX_MSG_CALL CCmdTarget::*)(CCmdUI*))&amp;memberFxn },<br>
		<br>
		#define <a name="ON_NOTIFY">ON_NOTIFY</a>(wNotifyCode, id, memberFxn) \<br>
		{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)id, 
		AfxSig_vNMHDRpl, \<br>
		(AFX_PMSG)(void (AFX_MSG_CALL CCmdTarget::*)(NMHDR*, 
		LRESULT*))&amp;memberFxn },<br>
		<br>
		#define <a name="ON_NOTIFY_RANGE">ON_NOTIFY_RANGE</a>(wNotifyCode, id, idLast, memberFxn) \<br>
		{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)idLast, 
		AfxSig_vwNMHDRpl, \<br>
		(AFX_PMSG)(void (AFX_MSG_CALL CCmdTarget::*)(UINT, NMHDR*, 
		LRESULT*))&amp;memberFxn },<br>
		<br>
		#define ON_NOTIFY_EX(wNotifyCode, id, memberFxn) \<br>
		{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)id, 
		AfxSig_bwNMHDRpl, \<br>
		(AFX_PMSG)(BOOL (AFX_MSG_CALL CCmdTarget::*)(UINT, NMHDR*, 
		LRESULT*))&amp;memberFxn },<br>
		<br>
		#define ON_NOTIFY_EX_RANGE(wNotifyCode, id, idLast, memberFxn) \<br>
		{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)idLast, 
		AfxSig_bwNMHDRpl, \<br>
		(AFX_PMSG)(BOOL (AFX_MSG_CALL CCmdTarget::*)(UINT, NMHDR*, 
		LRESULT*))&amp;memberFxn },<br>
		<br>
		// for general controls<br>
		#define ON_CONTROL(wNotifyCode, id, memberFxn) \<br>
		{ WM_COMMAND, (WORD)wNotifyCode, (WORD)id, (WORD)id, AfxSig_vv, \<br>
		(AFX_PMSG)&amp;memberFxn },<br>
		<br>
		#define <a name="ON_CONTROL_RANGE">ON_CONTROL_RANGE</a>(wNotifyCode, id, idLast, memberFxn) \<br>
		{ WM_COMMAND, (WORD)wNotifyCode, (WORD)id, (WORD)idLast, AfxSig_vw, \<br>
		(AFX_PMSG)(void (AFX_MSG_CALL CCmdTarget::*)(UINT))&amp;memberFxn },<br>
		<br>
		#define WM_REFLECT_BASE 0xBC00<br>
		<br>
		// for control notification reflection<br>
		#define ON_CONTROL_REFLECT(wNotifyCode, memberFxn) \<br>
		{ WM_COMMAND+WM_REFLECT_BASE, (WORD)wNotifyCode, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)&amp;memberFxn },<br>
		<br>
		#define ON_CONTROL_REFLECT_EX(wNotifyCode, memberFxn) \<br>
		{ WM_COMMAND+WM_REFLECT_BASE, (WORD)wNotifyCode, 0, 0, AfxSig_bv, \<br>
		(AFX_PMSG)(BOOL (AFX_MSG_CALL CCmdTarget::*)())&amp;memberFxn },<br>
		<br>
		#define ON_NOTIFY_REFLECT(wNotifyCode, memberFxn) \<br>
		{ WM_NOTIFY+WM_REFLECT_BASE, (WORD)(int)wNotifyCode, 0, 0, 
		AfxSig_vNMHDRpl, \<br>
		(AFX_PMSG)(void (AFX_MSG_CALL CCmdTarget::*)(NMHDR*, 
		LRESULT*))&amp;memberFxn },<br>
		<br>
		#define ON_NOTIFY_REFLECT_EX(wNotifyCode, memberFxn) \<br>
		{ WM_NOTIFY+WM_REFLECT_BASE, (WORD)(int)wNotifyCode, 0, 0, 
		AfxSig_bNMHDRpl, \<br>
		(AFX_PMSG)(BOOL (AFX_MSG_CALL CCmdTarget::*)(NMHDR*, 
		LRESULT*))&amp;memberFxn },<br>
		<br>
		#define ON_UPDATE_COMMAND_UI_REFLECT(memberFxn) \<br>
		{ WM_COMMAND+WM_REFLECT_BASE, (WORD)CN_UPDATE_COMMAND_UI, 0, 0, 
		AfxSig_cmdui, \<br>
		(AFX_PMSG)(void (AFX_MSG_CALL CCmdTarget::*)(CCmdUI*))&amp;memberFxn },<br>
		<br>
		/////////////////////////////////////////////////////////////////////////////<br>
		// <a name="Message_map_tables_for_Windows_messages">Message map tables for Windows messages</a><br>
		<br>
		#define ON_WM_CREATE() \<br>
		{ WM_CREATE, 0, 0, 0, AfxSig_is, \<br>
		(AFX_PMSG)(AFX_PMSGW)(int (AFX_MSG_CALL 
		CWnd::*)(LPCREATESTRUCT))&amp;OnCreate },<br>
		#define ON_WM_COPYDATA() \<br>
		{ WM_COPYDATA, 0, 0, 0, AfxSig_bWCDS, \<br>
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(CWnd*, 
		COPYDATASTRUCT*))&amp;OnCopyData },<br>
		#define ON_WM_DESTROY() \<br>
		{ WM_DESTROY, 0, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))&amp;OnDestroy },<br>
		#define ON_WM_MOVE() \<br>
		{ WM_MOVE, 0, 0, 0, AfxSig_vvii, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(int, int))&amp;OnMove },<br>
		#define ON_WM_SIZE() \<br>
		{ WM_SIZE, 0, 0, 0, AfxSig_vwii, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, int, 
		int))&amp;OnSize },<br>
		#define ON_WM_ACTIVATE() \<br>
		{ WM_ACTIVATE, 0, 0, 0, AfxSig_vwWb, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CWnd*, 
		BOOL))&amp;OnActivate },<br>
		#define ON_WM_SETFOCUS() \<br>
		{ WM_SETFOCUS, 0, 0, 0, AfxSig_vW, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*))&amp;OnSetFocus },<br>
		#define ON_WM_KILLFOCUS() \<br>
		{ WM_KILLFOCUS, 0, 0, 0, AfxSig_vW, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*))&amp;OnKillFocus },<br>
		#define ON_WM_ENABLE() \<br>
		{ WM_ENABLE, 0, 0, 0, AfxSig_vb, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL))&amp;OnEnable },<br>
		#define ON_WM_HELPINFO() \<br>
		{ WM_HELP, 0, 0, 0, AfxSig_bHELPINFO, \<br>
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(HELPINFO*))&amp;OnHelpInfo 
		},<br>
		#define ON_WM_PAINT() \<br>
		{ WM_PAINT, 0, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))&amp;OnPaint },<br>
		#define ON_WM_CLOSE() \<br>
		{ WM_CLOSE, 0, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))&amp;OnClose },<br>
		#define ON_WM_QUERYENDSESSION() \<br>
		{ WM_QUERYENDSESSION, 0, 0, 0, AfxSig_bv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL 
		CWnd::*)(void))&amp;OnQueryEndSession },<br>
		#define ON_WM_QUERYOPEN() \<br>
		{ WM_QUERYOPEN, 0, 0, 0, AfxSig_bv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(void))&amp;OnQueryOpen },<br>
		#define ON_WM_ERASEBKGND() \<br>
		{ WM_ERASEBKGND, 0, 0, 0, AfxSig_bD, \<br>
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(CDC*))&amp;OnEraseBkgnd },<br>
		#define ON_WM_SYSCOLORCHANGE() \<br>
		{ WM_SYSCOLORCHANGE, 0, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(void))&amp;OnSysColorChange },<br>
		#define ON_WM_ENDSESSION() \<br>
		{ WM_ENDSESSION, 0, 0, 0, AfxSig_vb, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL))&amp;OnEndSession },<br>
		#define ON_WM_SHOWWINDOW() \<br>
		{ WM_SHOWWINDOW, 0, 0, 0, AfxSig_vbw, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL, 
		UINT))&amp;OnShowWindow },<br>
		#define ON_WM_CTLCOLOR() \<br>
		{ WM_CTLCOLOR, 0, 0, 0, AfxSig_hDWw, \<br>
		(AFX_PMSG)(AFX_PMSGW)(HBRUSH (AFX_MSG_CALL CWnd::*)(CDC*, CWnd*, 
		UINT))&amp;OnCtlColor },<br>
		#define ON_WM_CTLCOLOR_REFLECT() \<br>
		{ WM_CTLCOLOR+WM_REFLECT_BASE, 0, 0, 0, AfxSig_hDw, \<br>
		(AFX_PMSG)(AFX_PMSGW)(HBRUSH (AFX_MSG_CALL CWnd::*)(CDC*, UINT))CtlColor 
		},<br>
		#if (WINVER &gt;= 0x0400)<br>
		#define ON_WM_SETTINGCHANGE() \<br>
		{ WM_SETTINGCHANGE, 0, 0, 0, AfxSig_vws, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		LPCTSTR))&amp;OnSettingChange },<br>
		#endif<br>
		#define ON_WM_WININICHANGE() \<br>
		{ WM_WININICHANGE, 0, 0, 0, AfxSig_vs, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(LPCTSTR))&amp;OnWinIniChange },<br>
		#define ON_WM_DEVMODECHANGE() \<br>
		{ WM_DEVMODECHANGE, 0, 0, 0, AfxSig_vs, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(LPTSTR))&amp;OnDevModeChange },<br>
		#define ON_WM_ACTIVATEAPP() \<br>
		{ WM_ACTIVATEAPP, 0, 0, 0, AfxSig_vbh, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL, 
		HTASK))&amp;OnActivateApp },<br>
		#define ON_WM_FONTCHANGE() \<br>
		{ WM_FONTCHANGE, 0, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))&amp;OnFontChange },<br>
		#define ON_WM_TIMECHANGE() \<br>
		{ WM_TIMECHANGE, 0, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))&amp;OnTimeChange },<br>
		#define ON_WM_CANCELMODE() \<br>
		{ WM_CANCELMODE, 0, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))&amp;OnCancelMode },<br>
		#define ON_WM_SETCURSOR() \<br>
		{ WM_SETCURSOR, 0, 0, 0, AfxSig_bWww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, 
		UINT))&amp;OnSetCursor },<br>
		#define ON_WM_MOUSEACTIVATE() \<br>
		{ WM_MOUSEACTIVATE, 0, 0, 0, AfxSig_iWww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(int (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, 
		UINT))&amp;OnMouseActivate },<br>
		#define ON_WM_CHILDACTIVATE() \<br>
		{ WM_CHILDACTIVATE, 0, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))&amp;OnChildActivate 
		},<br>
		#define ON_WM_GETMINMAXINFO() \<br>
		{ WM_GETMINMAXINFO, 0, 0, 0, AfxSig_vs, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(MINMAXINFO*))&amp;OnGetMinMaxInfo },<br>
		#define ON_WM_ICONERASEBKGND() \<br>
		{ WM_ICONERASEBKGND, 0, 0, 0, AfxSig_vD, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(CDC*))&amp;OnIconEraseBkgnd },<br>
		#define ON_WM_SPOOLERSTATUS() \<br>
		{ WM_SPOOLERSTATUS, 0, 0, 0, AfxSig_vww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		UINT))&amp;OnSpoolerStatus },<br>
		#define ON_WM_DRAWITEM() \<br>
		{ WM_DRAWITEM, 0, 0, 0, AfxSig_vOWNER, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(int, 
		LPDRAWITEMSTRUCT))&amp;OnDrawItem },<br>
		#define ON_WM_DRAWITEM_REFLECT() \<br>
		{ WM_DRAWITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vs, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(LPDRAWITEMSTRUCT))DrawItem },<br>
		#define ON_WM_MEASUREITEM() \<br>
		{ WM_MEASUREITEM, 0, 0, 0, AfxSig_vOWNER, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(int, 
		LPMEASUREITEMSTRUCT))&amp;OnMeasureItem },<br>
		#define ON_WM_MEASUREITEM_REFLECT() \<br>
		{ WM_MEASUREITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vs, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(LPMEASUREITEMSTRUCT))MeasureItem },<br>
		#define ON_WM_DELETEITEM() \<br>
		{ WM_DELETEITEM, 0, 0, 0, AfxSig_vOWNER, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(int, 
		LPDELETEITEMSTRUCT))&amp;OnDeleteItem },<br>
		#define ON_WM_DELETEITEM_REFLECT() \<br>
		{ WM_DELETEITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vs, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(LPDELETEITEMSTRUCT))DeleteItem },<br>
		#define ON_WM_CHARTOITEM() \<br>
		{ WM_CHARTOITEM, 0, 0, 0, AfxSig_iwWw, \<br>
		(AFX_PMSG)(AFX_PMSGW)(int (AFX_MSG_CALL CWnd::*)(UINT, CListBox*, 
		UINT))&amp;OnCharToItem },<br>
		#define ON_WM_CHARTOITEM_REFLECT() \<br>
		{ WM_CHARTOITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_iww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(int (AFX_MSG_CALL CWnd::*)(UINT, UINT))CharToItem 
		},<br>
		#define ON_WM_VKEYTOITEM() \<br>
		{ WM_VKEYTOITEM, 0, 0, 0, AfxSig_iwWw, \<br>
		(AFX_PMSG)(AFX_PMSGW)(int (AFX_MSG_CALL CWnd::*)(UINT, CListBox*, 
		UINT))&amp;OnVKeyToItem },<br>
		#define ON_WM_VKEYTOITEM_REFLECT() \<br>
		{ WM_VKEYTOITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_iww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(int (AFX_MSG_CALL CWnd::*)(UINT, UINT))VKeyToItem 
		},<br>
		#define ON_WM_QUERYDRAGICON() \<br>
		{ WM_QUERYDRAGICON, 0, 0, 0, AfxSig_hv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(HCURSOR (AFX_MSG_CALL CWnd::*)())&amp;OnQueryDragIcon 
		},<br>
		#define ON_WM_COMPAREITEM() \<br>
		{ WM_COMPAREITEM, 0, 0, 0, AfxSig_iis, \<br>
		(AFX_PMSG)(AFX_PMSGW)(int (AFX_MSG_CALL CWnd::*)(int, 
		LPCOMPAREITEMSTRUCT))&amp;OnCompareItem },<br>
		#define ON_WM_COMPAREITEM_REFLECT() \<br>
		{ WM_COMPAREITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_is, \<br>
		(AFX_PMSG)(AFX_PMSGW)(int (AFX_MSG_CALL 
		CWnd::*)(LPCOMPAREITEMSTRUCT))CompareItem },<br>
		#define ON_WM_COMPACTING() \<br>
		{ WM_COMPACTING, 0, 0, 0, AfxSig_vw, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT))&amp;OnCompacting },<br>
		#define ON_WM_NCCREATE() \<br>
		{ WM_NCCREATE, 0, 0, 0, AfxSig_is, \<br>
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL 
		CWnd::*)(LPCREATESTRUCT))&amp;OnNcCreate },<br>
		#define ON_WM_NCDESTROY() \<br>
		{ WM_NCDESTROY, 0, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))&amp;OnNcDestroy },<br>
		#define ON_WM_NCCALCSIZE() \<br>
		{ WM_NCCALCSIZE, 0, 0, 0, AfxSig_vCALC, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL, 
		NCCALCSIZE_PARAMS*))&amp;OnNcCalcSize },<br>
		#define ON_WM_NCHITTEST() \<br>
		{ WM_NCHITTEST, 0, 0, 0, AfxSig_wp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(UINT (AFX_MSG_CALL CWnd::*)(CPoint))&amp;OnNcHitTest 
		},<br>
		#define ON_WM_NCPAINT() \<br>
		{ WM_NCPAINT, 0, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))&amp;OnNcPaint },<br>
		#define ON_WM_NCACTIVATE() \<br>
		{ WM_NCACTIVATE, 0, 0, 0, AfxSig_bb, \<br>
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(BOOL))&amp;OnNcActivate },<br>
		#define ON_WM_GETDLGCODE() \<br>
		{ WM_GETDLGCODE, 0, 0, 0, AfxSig_wv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(UINT (AFX_MSG_CALL CWnd::*)(void))&amp;OnGetDlgCode },<br>
		#define ON_WM_NCMOUSEMOVE() \<br>
		{ WM_NCMOUSEMOVE, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnNcMouseMove },<br>
		#define ON_WM_NCLBUTTONDOWN() \<br>
		{ WM_NCLBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnNcLButtonDown },<br>
		#define ON_WM_NCLBUTTONUP() \<br>
		{ WM_NCLBUTTONUP, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnNcLButtonUp },<br>
		#define ON_WM_NCLBUTTONDBLCLK() \<br>
		{ WM_NCLBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnNcLButtonDblClk },<br>
		#define ON_WM_NCRBUTTONDOWN() \<br>
		{ WM_NCRBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnNcRButtonDown },<br>
		#define ON_WM_NCRBUTTONUP() \<br>
		{ WM_NCRBUTTONUP, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnNcRButtonUp },<br>
		#define ON_WM_NCRBUTTONDBLCLK() \<br>
		{ WM_NCRBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnNcRButtonDblClk },<br>
		#define ON_WM_NCMBUTTONDOWN() \<br>
		{ WM_NCMBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnNcMButtonDown },<br>
		#define ON_WM_NCMBUTTONUP() \<br>
		{ WM_NCMBUTTONUP, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnNcMButtonUp },<br>
		#define ON_WM_NCMBUTTONDBLCLK() \<br>
		{ WM_NCMBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnNcMButtonDblClk },<br>
		#define ON_WM_KEYDOWN() \<br>
		{ WM_KEYDOWN, 0, 0, 0, AfxSig_vwww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, 
		UINT))&amp;OnKeyDown },<br>
		#define ON_WM_KEYUP() \<br>
		{ WM_KEYUP, 0, 0, 0, AfxSig_vwww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, 
		UINT))&amp;OnKeyUp },<br>
		#define ON_WM_CHAR() \<br>
		{ WM_CHAR, 0, 0, 0, AfxSig_vwww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, 
		UINT))&amp;OnChar },<br>
		#define ON_WM_DEADCHAR() \<br>
		{ WM_DEADCHAR, 0, 0, 0, AfxSig_vwww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, 
		UINT))&amp;OnDeadChar },<br>
		#define ON_WM_SYSKEYDOWN() \<br>
		{ WM_SYSKEYDOWN, 0, 0, 0, AfxSig_vwww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, 
		UINT))&amp;OnSysKeyDown },<br>
		#define ON_WM_SYSKEYUP() \<br>
		{ WM_SYSKEYUP, 0, 0, 0, AfxSig_vwww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, 
		UINT))&amp;OnSysKeyUp },<br>
		#define ON_WM_SYSCHAR() \<br>
		{ WM_SYSCHAR, 0, 0, 0, AfxSig_vwww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, 
		UINT))&amp;OnSysChar },<br>
		#define ON_WM_SYSDEADCHAR() \<br>
		{ WM_SYSDEADCHAR, 0, 0, 0, AfxSig_vwww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, 
		UINT))&amp;OnSysDeadChar },<br>
		#define ON_WM_SYSCOMMAND() \<br>
		{ WM_SYSCOMMAND, 0, 0, 0, AfxSig_vwl, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		LPARAM))&amp;OnSysCommand },<br>
		#define ON_WM_TCARD() \<br>
		{ WM_TCARD, 0, 0, 0, AfxSig_vwl, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, DWORD))&amp;OnTCard 
		},<br>
		#define ON_WM_TIMER() \<br>
		{ WM_TIMER, 0, 0, 0, AfxSig_vw, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT))&amp;OnTimer },<br>
		#define ON_WM_HSCROLL() \<br>
		{ WM_HSCROLL, 0, 0, 0, AfxSig_vwwW, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, 
		CScrollBar*))&amp;OnHScroll },<br>
		#define ON_WM_HSCROLL_REFLECT() \<br>
		{ WM_HSCROLL+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vwwx, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT))HScroll },<br>
		#define ON_WM_VSCROLL() \<br>
		{ WM_VSCROLL, 0, 0, 0, AfxSig_vwwW, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, 
		CScrollBar*))&amp;OnVScroll },<br>
		#define ON_WM_VSCROLL_REFLECT() \<br>
		{ WM_VSCROLL+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vwwx, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT))VScroll },<br>
		#define ON_WM_INITMENU() \<br>
		{ WM_INITMENU, 0, 0, 0, AfxSig_vM, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CMenu*))&amp;OnInitMenu },<br>
		#define ON_WM_INITMENUPOPUP() \<br>
		{ WM_INITMENUPOPUP, 0, 0, 0, AfxSig_vMwb, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CMenu*, UINT, 
		BOOL))&amp;OnInitMenuPopup },<br>
		#define ON_WM_MENUSELECT() \<br>
		{ WM_MENUSELECT, 0, 0, 0, AfxSig_vwwh, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, 
		HMENU))&amp;OnMenuSelect },<br>
		#define ON_WM_MENUCHAR() \<br>
		{ WM_MENUCHAR, 0, 0, 0, AfxSig_lwwM, \<br>
		(AFX_PMSG)(AFX_PMSGW)(LRESULT (AFX_MSG_CALL CWnd::*)(UINT, UINT, 
		CMenu*))&amp;OnMenuChar },<br>
		#define ON_WM_ENTERIDLE() \<br>
		{ WM_ENTERIDLE, 0, 0, 0, AfxSig_vwW, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CWnd*))&amp;OnEnterIdle },<br>
		#define ON_WM_MOUSEMOVE() \<br>
		{ WM_MOUSEMOVE, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnMouseMove },<br>
		#define ON_WM_MOUSEWHEEL() \<br>
		{ WM_MOUSEWHEEL, 0, 0, 0, AfxSig_bwsp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(UINT, short, 
		CPoint))&amp;OnMouseWheel },<br>
		#define ON_WM_LBUTTONDOWN() \<br>
		{ WM_LBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnLButtonDown },<br>
		#define ON_WM_LBUTTONUP() \<br>
		{ WM_LBUTTONUP, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnLButtonUp },<br>
		#define ON_WM_LBUTTONDBLCLK() \<br>
		{ WM_LBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnLButtonDblClk },<br>
		#define ON_WM_RBUTTONDOWN() \<br>
		{ WM_RBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnRButtonDown },<br>
		#define ON_WM_RBUTTONUP() \<br>
		{ WM_RBUTTONUP, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnRButtonUp },<br>
		#define ON_WM_RBUTTONDBLCLK() \<br>
		{ WM_RBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnRButtonDblClk },<br>
		#define ON_WM_MBUTTONDOWN() \<br>
		{ WM_MBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnMButtonDown },<br>
		#define ON_WM_MBUTTONUP() \<br>
		{ WM_MBUTTONUP, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnMButtonUp },<br>
		#define ON_WM_MBUTTONDBLCLK() \<br>
		{ WM_MBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		CPoint))&amp;OnMButtonDblClk },<br>
		#define ON_WM_PARENTNOTIFY() \<br>
		{ WM_PARENTNOTIFY, 0, 0, 0, AfxSig_vwl, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		LPARAM))&amp;OnParentNotify },<br>
		#define ON_WM_PARENTNOTIFY_REFLECT() \<br>
		{ WM_PARENTNOTIFY+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vwl, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		LPARAM))ParentNotify },<br>
		#define ON_WM_MDIACTIVATE() \<br>
		{ WM_MDIACTIVATE, 0, 0, 0, AfxSig_vbWW, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL, CWnd*, 
		CWnd*))&amp;OnMDIActivate },<br>
		#define ON_WM_RENDERFORMAT() \<br>
		{ WM_RENDERFORMAT, 0, 0, 0, AfxSig_vw, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT))&amp;OnRenderFormat 
		},<br>
		#define ON_WM_RENDERALLFORMATS() \<br>
		{ WM_RENDERALLFORMATS, 0, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(void))&amp;OnRenderAllFormats },<br>
		#define ON_WM_DESTROYCLIPBOARD() \<br>
		{ WM_DESTROYCLIPBOARD, 0, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(void))&amp;OnDestroyClipboard },<br>
		#define ON_WM_DRAWCLIPBOARD() \<br>
		{ WM_DRAWCLIPBOARD, 0, 0, 0, AfxSig_vv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))&amp;OnDrawClipboard 
		},<br>
		#define ON_WM_PAINTCLIPBOARD() \<br>
		{ WM_PAINTCLIPBOARD, 0, 0, 0, AfxSig_vWh, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*, 
		HGLOBAL))&amp;OnPaintClipboard },<br>
		#define ON_WM_VSCROLLCLIPBOARD() \<br>
		{ WM_VSCROLLCLIPBOARD, 0, 0, 0, AfxSig_vWww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, 
		UINT))&amp;OnVScrollClipboard },<br>
		#define ON_WM_CONTEXTMENU() \<br>
		{ WM_CONTEXTMENU, 0, 0, 0, AfxSig_vWp, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*, 
		CPoint))&amp;OnContextMenu },<br>
		#define ON_WM_SIZECLIPBOARD() \<br>
		{ WM_SIZECLIPBOARD, 0, 0, 0, AfxSig_vWh, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*, 
		HGLOBAL))&amp;OnSizeClipboard },<br>
		#define ON_WM_ASKCBFORMATNAME() \<br>
		{ WM_ASKCBFORMATNAME, 0, 0, 0, AfxSig_vwl, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		LPTSTR))&amp;OnAskCbFormatName },<br>
		#define ON_WM_CHANGECBCHAIN() \<br>
		{ WM_CHANGECBCHAIN, 0, 0, 0, AfxSig_vhh, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(HWND, 
		HWND))&amp;OnChangeCbChain },<br>
		#define ON_WM_HSCROLLCLIPBOARD() \<br>
		{ WM_HSCROLLCLIPBOARD, 0, 0, 0, AfxSig_vWww, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, 
		UINT))&amp;OnHScrollClipboard },<br>
		#define ON_WM_QUERYNEWPALETTE() \<br>
		{ WM_QUERYNEWPALETTE, 0, 0, 0, AfxSig_bv, \<br>
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL 
		CWnd::*)(void))&amp;OnQueryNewPalette },<br>
		#define ON_WM_PALETTECHANGED() \<br>
		{ WM_PALETTECHANGED, 0, 0, 0, AfxSig_vW, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(CWnd*))&amp;OnPaletteChanged },<br>
		<br>
		#define ON_WM_PALETTEISCHANGING() \<br>
		{ WM_PALETTEISCHANGING, 0, 0, 0, AfxSig_vW, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(CWnd*))&amp;OnPaletteIsChanging },<br>
		#define ON_WM_DROPFILES() \<br>
		{ WM_DROPFILES, 0, 0, 0, AfxSig_vh, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(HDROP))&amp;OnDropFiles },<br>
		#define ON_WM_WINDOWPOSCHANGING() \<br>
		{ WM_WINDOWPOSCHANGING, 0, 0, 0, AfxSig_vPOS, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(WINDOWPOS*))&amp;OnWindowPosChanging },<br>
		#define ON_WM_WINDOWPOSCHANGED() \<br>
		{ WM_WINDOWPOSCHANGED, 0, 0, 0, AfxSig_vPOS, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(WINDOWPOS*))&amp;OnWindowPosChanged },<br>
		<br>
		#define ON_WM_EXITMENULOOP() \<br>
		{ WM_EXITMENULOOP, 0, 0, 0, AfxSig_vb, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL))&amp;OnExitMenuLoop 
		},<br>
		#define ON_WM_ENTERMENULOOP() \<br>
		{ WM_ENTERMENULOOP, 0, 0, 0, AfxSig_vb, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL))&amp;OnEnterMenuLoop 
		},<br>
		<br>
		#define ON_WM_STYLECHANGED() \<br>
		{ WM_STYLECHANGED, 0, 0, 0, AfxSig_viSS, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(int, 
		LPSTYLESTRUCT))&amp;OnStyleChanged },<br>
		#define ON_WM_STYLECHANGING() \<br>
		{ WM_STYLECHANGING, 0, 0, 0, AfxSig_viSS, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(int, 
		LPSTYLESTRUCT))&amp;OnStyleChanging },<br>
		#define ON_WM_SIZING() \<br>
		{ WM_SIZING, 0, 0, 0, AfxSig_vwSIZING, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		LPRECT))&amp;OnSizing },<br>
		#define ON_WM_MOVING() \<br>
		{ WM_MOVING, 0, 0, 0, AfxSig_vwMOVING, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, 
		LPRECT))&amp;OnMoving },<br>
		#define ON_WM_CAPTURECHANGED() \<br>
		{ WM_CAPTURECHANGED, 0, 0, 0, AfxSig_vW2, \<br>
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL 
		CWnd::*)(CWnd*))&amp;OnCaptureChanged },<br>
		#define ON_WM_DEVICECHANGE() \<br>
		{ WM_DEVICECHANGE, 0, 0, 0, AfxSig_bwl, \<br>
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(UINT, 
		DWORD))&amp;OnDeviceChange },<br>
		<br>
		/////////////////////////////////////////////////////////////////////////////<br>
		// <a name="Message_map_tables_for_Control_Notification_messages">Message map tables for Control Notification messages</a><br>
		<br>
		// Static control notification codes<br>
		#define ON_STN_CLICKED(id, memberFxn) \<br>
		ON_CONTROL(STN_CLICKED, id, memberFxn)<br>
		#define ON_STN_DBLCLK(id, memberFxn) \<br>
		ON_CONTROL(STN_DBLCLK, id, memberFxn)<br>
		#define ON_STN_ENABLE(id, memberFxn) \<br>
		ON_CONTROL(STN_ENABLE, id, memberFxn)<br>
		#define ON_STN_DISABLE(id, memberFxn) \<br>
		ON_CONTROL(STN_DISABLE, id, memberFxn)<br>
		<br>
		<br>
		// Edit Control Notification Codes<br>
		#define ON_EN_SETFOCUS(id, memberFxn) \<br>
		ON_CONTROL(EN_SETFOCUS, id, memberFxn)<br>
		#define ON_EN_KILLFOCUS(id, memberFxn) \<br>
		ON_CONTROL(EN_KILLFOCUS, id, memberFxn)<br>
		#define ON_EN_CHANGE(id, memberFxn) \<br>
		ON_CONTROL(EN_CHANGE, id, memberFxn)<br>
		#define ON_EN_UPDATE(id, memberFxn) \<br>
		ON_CONTROL(EN_UPDATE, id, memberFxn)<br>
		#define ON_EN_ERRSPACE(id, memberFxn) \<br>
		ON_CONTROL(EN_ERRSPACE, id, memberFxn)<br>
		#define ON_EN_MAXTEXT(id, memberFxn) \<br>
		ON_CONTROL(EN_MAXTEXT, id, memberFxn)<br>
		#define ON_EN_HSCROLL(id, memberFxn) \<br>
		ON_CONTROL(EN_HSCROLL, id, memberFxn)<br>
		#define ON_EN_VSCROLL(id, memberFxn) \<br>
		ON_CONTROL(EN_VSCROLL, id, memberFxn)<br>
		<br>
		// User Button Notification Codes<br>
		#define ON_BN_CLICKED(id, memberFxn) \<br>
		ON_CONTROL(BN_CLICKED, id, memberFxn)<br>
		#define ON_BN_DOUBLECLICKED(id, memberFxn) \<br>
		ON_CONTROL(BN_DOUBLECLICKED, id, memberFxn)<br>
		#define ON_BN_SETFOCUS(id, memberFxn) \<br>
		ON_CONTROL(BN_SETFOCUS, id, memberFxn)<br>
		#define ON_BN_KILLFOCUS(id, memberFxn) \<br>
		ON_CONTROL(BN_KILLFOCUS, id, memberFxn)<br>
		<br>
		// old BS_USERBUTTON button notifications - obsolete in Win31<br>
		#define ON_BN_PAINT(id, memberFxn) \<br>
		ON_CONTROL(BN_PAINT, id, memberFxn)<br>
		#define ON_BN_HILITE(id, memberFxn) \<br>
		ON_CONTROL(BN_HILITE, id, memberFxn)<br>
		#define ON_BN_UNHILITE(id, memberFxn) \<br>
		ON_CONTROL(BN_UNHILITE, id, memberFxn)<br>
		#define ON_BN_DISABLE(id, memberFxn) \<br>
		ON_CONTROL(BN_DISABLE, id, memberFxn)<br>
		<br>
		// Listbox Notification Codes<br>
		#define ON_LBN_ERRSPACE(id, memberFxn) \<br>
		ON_CONTROL(LBN_ERRSPACE, id, memberFxn)<br>
		#define ON_LBN_SELCHANGE(id, memberFxn) \<br>
		ON_CONTROL(LBN_SELCHANGE, id, memberFxn)<br>
		#define ON_LBN_DBLCLK(id, memberFxn) \<br>
		ON_CONTROL(LBN_DBLCLK, id, memberFxn)<br>
		#define ON_LBN_SELCANCEL(id, memberFxn) \<br>
		ON_CONTROL(LBN_SELCANCEL, id, memberFxn)<br>
		#define ON_LBN_SETFOCUS(id, memberFxn) \<br>
		ON_CONTROL(LBN_SETFOCUS, id, memberFxn)<br>
		#define ON_LBN_KILLFOCUS(id, memberFxn) \<br>
		ON_CONTROL(LBN_KILLFOCUS, id, memberFxn)<br>
		<br>
		// Check Listbox Notification codes<br>
		#define CLBN_CHKCHANGE (40)<br>
		#define ON_CLBN_CHKCHANGE(id, memberFxn) \<br>
		ON_CONTROL(CLBN_CHKCHANGE, id, memberFxn)<br>
		<br>
		// Combo Box Notification Codes<br>
		#define ON_CBN_ERRSPACE(id, memberFxn) \<br>
		ON_CONTROL(CBN_ERRSPACE, id, memberFxn)<br>
		#define ON_CBN_SELCHANGE(id, memberFxn) \<br>
		ON_CONTROL(CBN_SELCHANGE, id, memberFxn)<br>
		#define ON_CBN_DBLCLK(id, memberFxn) \<br>
		ON_CONTROL(CBN_DBLCLK, id, memberFxn)<br>
		#define ON_CBN_SETFOCUS(id, memberFxn) \<br>
		ON_CONTROL(CBN_SETFOCUS, id, memberFxn)<br>
		#define ON_CBN_KILLFOCUS(id, memberFxn) \<br>
		ON_CONTROL(CBN_KILLFOCUS, id, memberFxn)<br>
		#define ON_CBN_EDITCHANGE(id, memberFxn) \<br>
		ON_CONTROL(CBN_EDITCHANGE, id, memberFxn)<br>
		#define ON_CBN_EDITUPDATE(id, memberFxn) \<br>
		ON_CONTROL(CBN_EDITUPDATE, id, memberFxn)<br>
		#define ON_CBN_DROPDOWN(id, memberFxn) \<br>
		ON_CONTROL(CBN_DROPDOWN, id, memberFxn)<br>
		#define ON_CBN_CLOSEUP(id, memberFxn) \<br>
		ON_CONTROL(CBN_CLOSEUP, id, memberFxn)<br>
		#define ON_CBN_SELENDOK(id, memberFxn) \<br>
		ON_CONTROL(CBN_SELENDOK, id, memberFxn)<br>
		#define ON_CBN_SELENDCANCEL(id, memberFxn) \<br>
		ON_CONTROL(CBN_SELENDCANCEL, id, memberFxn)<br>
		<br>
		/////////////////////////////////////////////////////////////////////////////<br>
		// <a name="User_extensions_for_message_map_entries">User extensions for message map entries</a><br>
		<br>
		// for Windows messages<br>
		#define <a name="ON_MESSAGE">ON_MESSAGE</a>(message, memberFxn) \<br>
		{ message, 0, 0, 0, AfxSig_lwl, \<br>
		(AFX_PMSG)(AFX_PMSGW)(LRESULT (AFX_MSG_CALL CWnd::*)(WPARAM, 
		LPARAM))&amp;memberFxn },<br>
		<br>
		// for Registered Windows messages<br>
		#define <a name="ON_REGISTERED_MESSAGE">ON_REGISTERED_MESSAGE</a>(nMessageVariable, memberFxn) \<br>
		{ 0xC000, 0, 0, 0, (UINT)(UINT*)(&amp;nMessageVariable), \<br>
		/*implied 'AfxSig_lwl'*/ \<br>
		(AFX_PMSG)(AFX_PMSGW)(LRESULT (AFX_MSG_CALL CWnd::*)(WPARAM, 
		LPARAM))&amp;memberFxn },<br>
		<br>
		// for Thread messages<br>
		#define <a name="ON_THREAD_MESSAGE">ON_THREAD_MESSAGE</a>(message, memberFxn) \<br>
		{ message, 0, 0, 0, AfxSig_vwl, \<br>
		(AFX_PMSG)(AFX_PMSGT)(void (AFX_MSG_CALL CWinThread::*)(WPARAM, 
		LPARAM))&amp;memberFxn },<br>
		<br>
		// for Registered Windows messages<br>
		#define <a name="ON_REGISTERED_THREAD_MESSAGE">ON_REGISTERED_THREAD_MESSAGE</a>(nMessageVariable, memberFxn) \<br>
		{ 0xC000, 0, 0, 0, (UINT)(UINT*)(&amp;nMessageVariable), \<br>
		/*implied 'AfxSig_vwl'*/ \<br>
		(AFX_PMSG)(AFX_PMSGT)(void (AFX_MSG_CALL CWinThread::*)(WPARAM, 
		LPARAM))&amp;memberFxn },<br>
		<br>
		/////////////////////////////////////////////////////////////////////////////</td>
	</tr>
</table>
<p>　</p>
<p><span class="ShowLink" id="showall1"  onclick="Call ShowAll()">显示所有文字</span>
</p>
</body>

</html>