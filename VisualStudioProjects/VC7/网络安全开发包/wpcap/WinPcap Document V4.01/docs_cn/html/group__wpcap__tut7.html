<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>WinPcap: 处理脱机堆文件</title>
<link href="style.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<!-- Translation(Chinese) By CoffeeCat -->
<!-- http://www.CoffeeCat.net.cn-->
<div class="tabs">
  <ul>
    <li id="current"><a href="main.html"><span>主 页</span></a></li>
    <li><a href="modules.html"><span>模块</span></a></li>
    <li><a href="annotated.html"><span>数据结构</span></a></li>
    <li><a href="files.html"><span>文件</span></a></li>
    <li><a href="pages.html"><span>相关页面</span></a></li>
  </ul></div>
<h1>处理脱机堆文件</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
在本讲中，我们将学习如何处理捕获到文件中的数据包。 WinPcap提供了很多函数来将网络数据流保存到文件并读取它们 -- 本讲将教你如何使用这些函数。我们还将看到如何使用WinPcap内核堆特性来获取一个高性能的堆。(请注意：此时，由于一些有关新内核缓冲的问题，这些特性将无法使用)
<p>
堆文件的格式是libpcap的一种。这种格式中，包含了被捕捉到的包的二进制数据，并且，这种格式是许多网络工具所使用的一种标准，这些工具包括WinDump，Etheral和Snort。<p>
<b>保存数据包到堆文件</b><p>
首先，让我们看一下如何将一个数据包写成libpcap的格式。<p>
接下来的例子讲从一个选定的接口捕获数据包，并且将它们保存到用户指定的文件中。<p>
<div class="fragment">
  <pre class="fragment"><span class="preprocessor">#include "pcap.h"</span>

<span class="comment">/* 回调函数原型 */</span>
<span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data);

main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
<a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
<a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
<span class="keywordtype">int</span> inum;
<span class="keywordtype">int</span> i=0;
<a class="code" href="group__wpcap__def.html#g4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *adhandle;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#gcd448353957d92c98fccc29e1fc8d927">PCAP_ERRBUF_SIZE</a>];
<a class="code" href="group__wpcap__def.html#gb8c7858aa3a7e3158d9d58cb113a2ae8">pcap_dumper_t</a> *dumpfile;


    
    <span class="comment">/* 检查程序输入参数 */</span>
    <span class="keywordflow">if</span>(argc != 2)
    {
        printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* 获取本机设备列表 */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#g98f36e62c95c6ad81eaa8b2bbeb8f16e">pcap_findalldevs_ex</a>(<a class="code" href="group__remote__source__string.html#g6d7103b8a7e1eca8c325bd8f32c361c3">PCAP_SRC_IF_STRING</a>, NULL, &amp;alldevs, errbuf) == -1)
    {
        fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
        exit(1);
    }
    
    <span class="comment">/* 打印列表 */</span>
    <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#81508e6e4e41ca4235c8d6b51913c536">next</a>)
    {
        printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#5ac083a645d964373f022d03df4849c8">name</a>);
        if (d-&gt;<a class="code" href="structpcap__if.html#8444d6e0dfe2bbab0b5e7b24308f1559">description</a>)
            printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#8444d6e0dfe2bbab0b5e7b24308f1559">description</a>);
        <span class="keywordflow">else</span>
            printf(<span class="stringliteral">" (No description available)\n"</span>);
    }

    <span class="keywordflow">if</span>(i==0)
    {
        printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
    scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
    
    <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
    {
        printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
        <span class="comment">/* 释放列表 */</span>
        <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
        
    <span class="comment">/* 跳转到选中的适配器 */</span>
    <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#81508e6e4e41ca4235c8d6b51913c536">next</a>, i++);
    
    
    <span class="comment">/* 打开适配器 */</span>
    <span class="keywordflow">if</span> ( (adhandle= <a class="code" href="group__wpcapfunc.html#g2b64c7b6490090d1d37088794f1f1791">pcap_open</a>(d-&gt;<a class="code" href="structpcap__if.html#5ac083a645d964373f022d03df4849c8">name</a>,          <span class="comment">// 设备名</span>
                              65536,            <span class="comment">// 要捕捉的数据包的部分 </span>
                                        		   <span class="comment">// 65535保证能捕获到不同数据链路层上的每个数据包的全部内容</span>
                              <a class="code" href="group__remote__open__flags.html#g9134ce51a9a6a7d497c3dee5affdc3b9">PCAP_OPENFLAG_PROMISCUOUS</a>,    <span class="comment">// </span><span class="comment">混杂模式</span>
                              1000,             <span class="comment">// 读取超时时间</span>
                              NULL,             <span class="comment">// 远程机器验证</span>
                              errbuf            <span class="comment">// 错误缓冲池</span>
                              ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#5ac083a645d964373f022d03df4849c8">name</a>);
        <span class="comment">/* 释放设备列表 */</span>
        <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }

    <span class="comment">/* 打开堆文件 */</span>
    dumpfile = <a class="code" href="group__wpcapfunc.html#g9506c33d580fdb5e5c288dba0f8a085c">pcap_dump_open</a>(adhandle, argv[1]);

    <span class="keywordflow">if</span>(dumpfile==NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nError opening output file\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"\nlistening on %s... Press Ctrl+C to stop...\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#8444d6e0dfe2bbab0b5e7b24308f1559">description</a>);
    
    <span class="comment">/* 释放设备列表 */</span>
    <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);
    
    <span class="comment">/* 开始捕获 */</span>
    <a class="code" href="group__wpcapfunc.html#g6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop</a>(adhandle, 0, packet_handler, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)dumpfile);

    <span class="keywordflow">return</span> 0;
}

<span class="comment">/* 回调函数，用来处理数据包 */</span>
<span class="keywordtype">void</span> packet_handler(u_char *dumpfile, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    <span class="comment">/* 保存数据包到堆文件 */</span>
    <a class="code" href="group__wpcapfunc.html#g659439bf5aa3988b5a92d31990fbf437">pcap_dump</a>(dumpfile, header, pkt_data);
}
</pre>
</div><p>
你可以看到，这个程序的结构和前面几讲的程序非常相似，它们的区别有：<ul>
<li>只有当接口打开时，调用 <a class="el" href="group__wpcapfunc.html#g9506c33d580fdb5e5c288dba0f8a085c">pcap_dump_open()</a> 才是有效的。 这个调用将打开一个堆文件，并将它关联到特定的接口上。</li>
<li>数据包将会通过 <a class="el" href="group__wpcapfunc.html#g659439bf5aa3988b5a92d31990fbf437">pcap_dump()</a> 函数写入堆文件中，这个函数是packet_handler()的回调函数。 <a class="el" href="group__wpcapfunc.html#g659439bf5aa3988b5a92d31990fbf437">pcap_dump()</a> 的参数和 <a class="el" href="group__wpcapfunc.html#gc429cf4f27205111259ff7b02a82eeab">pcap_handler()</a> 函数中的参数是一一对应的。</li></ul>
<p>
<b>从堆文件中读取数据包</b><p>
既然我们有了可用的堆文件，那我们就能读取它的内容了。 以下代码将打开一个WinPcap/libpcap的堆文件，并显示文件中每一个包的信息。文件通过 <a class="el" href="group__wpcapfunc.html#g91078168a13de8848df2b7b83d1f5b69">pcap_open_offline()</a> 打开，然后，我们通常使用 <a class="el" href="group__wpcapfunc.html#g6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop()</a> 来有序获取数据包。你可以看到，从脱机文件中读取数据包和从物理接口中接收它们是很相似的。<p>
这个例子还会介绍另一个函数：pcap_createsrcsrc()。这个函数用于创建一个源字符串，这个源字符串以一个标志开头，这个标志会告诉WinPcap这个源的类型。比如，使用"rpcap://"标志来打开一个适配器，使用"file://"来打开一个文件。如果 <a class="el" href="group__wpcapfunc.html#g98f36e62c95c6ad81eaa8b2bbeb8f16e">pcap_findalldevs_ex()</a> 已经被使用，那么这部是不需要的，因为其返回值已经包含了这些字符串。然而，在这个例子中，我们需要它。因为文件的名字来自于用户的输入。<p>
<div class="fragment">
  <pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="preprocessor">#define LINE_LEN 16</span>
<span class="preprocessor"></span>
<span class="keywordtype">void</span> dispatcher_handler(u_char *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *, <span class="keyword">const</span> u_char *);

main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
<a class="code" href="group__wpcap__def.html#g4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *fp;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#gcd448353957d92c98fccc29e1fc8d927">PCAP_ERRBUF_SIZE</a>];
<span class="keywordtype">char</span> source[<a class="code" href="group__remote__struct.html#gcacb155b596f7511f714de129ae32c97">PCAP_BUF_SIZE</a>];

    <span class="keywordflow">if</span>(argc != 2){

        printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
        <span class="keywordflow">return</span> -1;

    }

    <span class="comment">/* 根据新WinPcap语法创建一个源字符串 */</span>
    <span class="keywordflow">if</span> ( <a class="code" href="group__wpcapfunc.html#ga3111e10f930a9772a32a922b26948b0">pcap_createsrcstr</a>( source,         <span class="comment">// 源字符串</span>
                            <a class="code" href="group__remote__source__ID.html#g9188ad0fc0d12fc51d1e9f5e78bf9440">PCAP_SRC_FILE</a>,  <span class="comment">// 我们要打开的文件</span>
                            NULL,           <span class="comment">// 远程主机</span>
                            NULL,           <span class="comment">// 远程主机端口</span>
                            argv[1],        <span class="comment">// 我们要打开的文件名</span>
                            errbuf          <span class="comment">// 错误缓冲区</span>
                            ) != 0)
    {
        fprintf(stderr,<span class="stringliteral">"\nError creating a source string\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* 打开捕获文件 */</span>
    <span class="keywordflow">if</span> ( (fp= <a class="code" href="group__wpcapfunc.html#g2b64c7b6490090d1d37088794f1f1791">pcap_open</a>(source,         <span class="comment">// 设备名</span>
                        65536,          <span class="comment">// 要捕捉的数据包的部分</span>
                                        <span class="comment">// 65535保证能捕获到不同数据链路层上的每个数据包的全部内容</span>
                         <a class="code" href="group__remote__open__flags.html#g9134ce51a9a6a7d497c3dee5affdc3b9">PCAP_OPENFLAG_PROMISCUOUS</a>,     <span class="comment">// 混杂模式</span>
                         1000,              <span class="comment">// 读取超时时间</span>
                         NULL,              <span class="comment">// 远程机器验证</span>
                         errbuf         <span class="comment">// </span><span class="comment">错误缓冲池</span>
                         ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the file %s.\n"</span>, source);
        <span class="keywordflow">return</span> -1;
    }

    <span class="comment">// 读取并解析数据包，直到EOF为真</span>
    <a class="code" href="group__wpcapfunc.html#g6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop</a>(fp, 0, dispatcher_handler, NULL);

    <span class="keywordflow">return</span> 0;
}



<span class="keywordtype">void</span> dispatcher_handler(u_char *temp1, 
                        <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    u_int i=0;
    
    <span class="comment">/* 打印pkt时间戳和pkt长度 */</span>
    printf(<span class="stringliteral">"%ld:%ld (%ld)\n"</span>, header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_sec, header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#728f264db4f5cc304742565a2bcdbeea">len</a>);          
    
    <span class="comment">/* 打印数据包 */</span>
    <span class="keywordflow">for</span> (i=1; (i &lt; header-&gt;<a class="code" href="structpcap__pkthdr.html#ac5771ed2efd92508bb4fe650f2ce7d7">caplen</a> + 1 ) ; i++)
    {
        printf(<span class="stringliteral">"%.2x "</span>, pkt_data[i-1]);
        <span class="keywordflow">if</span> ( (i % LINE_LEN) == 0) printf(<span class="stringliteral">"\n"</span>);
    }
    
    printf(<span class="stringliteral">"\n\n"</span>);     
    
}
</pre>
</div><p>
下面的程序同样实现了如上功能，只是，我们使用了 <a class="el" href="group__wpcapfunc.html#g439439c2eae61161dc1efb1e03a81133">pcap_next_ex()</a> 函数来代替需要进行回调的 <a class="el" href="group__wpcapfunc.html#g6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop()</a> 。<p>
<div class="fragment">
  <pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="preprocessor">#define LINE_LEN 16</span>
<span class="preprocessor"></span>
main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
<a class="code" href="group__wpcap__def.html#g4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *fp;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#gcd448353957d92c98fccc29e1fc8d927">PCAP_ERRBUF_SIZE</a>];
<span class="keywordtype">char</span> source[<a class="code" href="group__remote__struct.html#gcacb155b596f7511f714de129ae32c97">PCAP_BUF_SIZE</a>];
<span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header;
<span class="keyword">const</span> u_char *pkt_data;
u_int i=0;
<span class="keywordtype">int</span> res;

    <span class="keywordflow">if</span>(argc != 2)
    {
        printf(<span class="stringliteral">"usage: %s filename"</span>, argv[0]);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* 根据新WinPcap语法创建一个源字符串 */</span>
    <span class="keywordflow">if</span> ( <a class="code" href="group__wpcapfunc.html#ga3111e10f930a9772a32a922b26948b0">pcap_createsrcstr</a>( source,         <span class="comment">// 源字符串</span>
                            <a class="code" href="group__remote__source__ID.html#g9188ad0fc0d12fc51d1e9f5e78bf9440">PCAP_SRC_FILE</a>,  <span class="comment">// 我们要打开的文件</span>
                            NULL,           <span class="comment">// 远程主机</span>
                            NULL,           <span class="comment">// 远程主机端口</span>
                            argv[1],        <span class="comment">// 我们要打开的文件名</span>
                            errbuf          <span class="comment">// 错误缓冲区</span>
                            ) != 0)
    {
        fprintf(stderr,<span class="stringliteral">"\nError creating a source string\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* 打开捕获文件 */</span>
    <span class="keywordflow">if</span> ( (fp= <a class="code" href="group__wpcapfunc.html#g2b64c7b6490090d1d37088794f1f1791">pcap_open</a>(source,         <span class="comment">// 设备名</span>
                        65536,          <span class="comment">// 要捕捉的数据包的部分</span>
                                        <span class="comment">// 65535保证能捕获到不同数据链路层上的每个数据包的全部内容</span>
                         <a class="code" href="group__remote__open__flags.html#g9134ce51a9a6a7d497c3dee5affdc3b9">PCAP_OPENFLAG_PROMISCUOUS</a>,     <span class="comment">// 混杂模式</span>
                         1000,              <span class="comment">// 读取超时时间</span>
                         NULL,              <span class="comment">// 远程机器验证</span>
                         errbuf         <span class="comment">// </span><span class="comment">错误缓冲池</span>
                         ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the file %s.\n"</span>, source);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* 从文件获取数据包 */</span>
    <span class="keywordflow">while</span>((res = <a class="code" href="group__wpcapfunc.html#g439439c2eae61161dc1efb1e03a81133">pcap_next_ex</a>( fp, &amp;header, &amp;pkt_data)) &gt;= 0)
    {
        <span class="comment">/* 打印pkt时间戳和pkt长度 */</span>
        printf(<span class="stringliteral">"%ld:%ld (%ld)\n"</span>, header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_sec, header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#728f264db4f5cc304742565a2bcdbeea">len</a>);          
        
        <span class="comment">/* 打印数据包 */</span>
        <span class="keywordflow">for</span> (i=1; (i &lt; header-&gt;<a class="code" href="structpcap__pkthdr.html#ac5771ed2efd92508bb4fe650f2ce7d7">caplen</a> + 1 ) ; i++)
        {
            printf(<span class="stringliteral">"%.2x "</span>, pkt_data[i-1]);
            <span class="keywordflow">if</span> ( (i % LINE_LEN) == 0) printf(<span class="stringliteral">"\n"</span>);
        }
        
        printf(<span class="stringliteral">"\n\n"</span>);     
    }
    
    
    <span class="keywordflow">if</span> (res == -1)
    {
        printf(<span class="stringliteral">"Error reading the packets: %s\n"</span>, <a class="code" href="group__wpcapfunc.html#g81305cb154e4497e95bbb9b708631a3a">pcap_geterr</a>(fp));
    }
    
    <span class="keywordflow">return</span> 0;
}

</pre>
</div><p>
<b>使用pcap_live_dump将包写入堆文件</b><p>
<b>注意：</b> 此时，由于新内核缓冲的一些问题，这个特性可能不可用。
<p>
WinPcap的最近几个版本提供了一个更好的途径，来讲数据流保存到磁盘，那就是 <a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a> 函数。 <a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a> 函数有3个参数：文件名，文件最大的大小(字节为单位)，和文件可以允许存储的数据包的最大数量 。 0表示没有限制。 注意，在调用 <a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a>  将数据流保存下来之前，程序可以设置过滤器(使用 <a class="el" href="group__wpcapfunc.html#gf5f9cfe85dad0967ff607e5159b1ba61">pcap_setfilter()</a>，详情请参见教程的 <a class="el" href="group__wpcap__tut5.html">过滤数据包这部分</a>) ，这样，我们就可以定义要保存的那部分数据流了。
<p>
<a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a> 不会被阻塞， 因此，它开始堆处理后会立即返回。 堆处理以异步的方式进行，直到文件达到最大大小或者存储的数据包达到最大数量。
<p>
应用程序可以使用 <a class="el" href="group__wpcapfunc.html#gfe8a334f3a7ae2dc7f52e96523da39be">pcap_live_dump_ended()</a>来检查数据是否存储完毕。 <b>特别注意：</b>  <em>sync</em> 参数必须是非零的， 如果它们是0，那么程序将永远被阻塞。<p>
<div class="fragment">
  <pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)</span>
<span class="comment"> * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)</span>
<span class="comment"> * All rights reserved.</span>
<span class="comment"> *</span>
<span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<span class="comment"> * modification, are permitted provided that the following conditions</span>
<span class="comment"> * are met:</span>
<span class="comment"> *</span>
<span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
<span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="comment"> * notice, this list of conditions and the following disclaimer in the</span>
<span class="comment"> * documentation and/or other materials provided with the distribution.</span>
<span class="comment"> * 3. Neither the name of the Politecnico di Torino, CACE Technologies </span>
<span class="comment"> * nor the names of its contributors may be used to endorse or promote </span>
<span class="comment"> * products derived from this software without specific prior written </span>
<span class="comment"> * permission.</span>
<span class="comment"> *</span>
<span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="comment"> *</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="preprocessor">#error At the moment the kernel dump feature is not supported in the driver</span>
<span class="preprocessor"></span>
main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
    
    <a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs, *d;
    <a class="code" href="group__wpcap__def.html#g4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *fp;
    u_int inum, i=0;
    <span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#gcd448353957d92c98fccc29e1fc8d927">PCAP_ERRBUF_SIZE</a>];

    printf(<span class="stringliteral">"kdump: saves the network traffic to file using WinPcap kernel-level dump faeature.\n"</span>);
    printf(<span class="stringliteral">"\t Usage: %s [adapter] | dump_file_name max_size max_packs\n"</span>, argv[0]);
    printf(<span class="stringliteral">"\t Where: max_size is the maximum size that the dump file will reach (0 means no limit)\n"</span>);
    printf(<span class="stringliteral">"\t Where: max_packs is the maximum number of packets that will be saved (0 means no limit)\n\n"</span>);


    <span class="keywordflow">if</span>(argc &lt; 5){

        <span class="comment">/* 用户没有提供数据源。获取设备列表 */</span>
        <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#g7b128eaeef627b408f6a6e2a2f5eb45d">pcap_findalldevs</a>(&amp;alldevs, errbuf) == -1)
        {
            fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
            exit(1);
        }
        
        <span class="comment">/* 打印列表 */</span>
        <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#81508e6e4e41ca4235c8d6b51913c536">next</a>)
        {
            printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#5ac083a645d964373f022d03df4849c8">name</a>);
            if (d-&gt;<a class="code" href="structpcap__if.html#8444d6e0dfe2bbab0b5e7b24308f1559">description</a>)
                printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#8444d6e0dfe2bbab0b5e7b24308f1559">description</a>);
            <span class="keywordflow">else</span>
                printf(<span class="stringliteral">" (No description available)\n"</span>);
        }
        
        <span class="keywordflow">if</span>(i==0)
        {
            printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
            <span class="keywordflow">return</span> -1;
        }
        
        printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
        scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
        
        <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
        {
            printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
            <span class="comment">/* 释放列表 */</span>
            <span class="keywordflow">return</span> -1;
        }
        
        <span class="comment">/* 跳转到所选的设备 */</span>
        <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#81508e6e4e41ca4235c8d6b51913c536">next</a>, i++);
        
        <span class="comment">/* 打开设备 */</span>
        <span class="keywordflow">if</span> ( (fp = <a class="code" href="group__wpcapfunc.html#gae6abe06e15c87b803f69773822beca8">pcap_open_live</a>(d-&gt;<a class="code" href="structpcap__if.html#5ac083a645d964373f022d03df4849c8">name</a>, 100, 1, 20, errbuf) ) == NULL)
        {
            fprintf(stderr,<span class="stringliteral">"\nError opening adapter\n"</span>);
            <span class="keywordflow">return</span> -1;
        }

        <span class="comment">/* 释放设备列表 */</span>
        <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);

        <span class="comment">/* 开始堆过程 */</span>
        <span class="keywordflow">if</span>(<a class="code" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump</a>(fp, argv[1], atoi(argv[2]), atoi(argv[3]))==-1){
            printf(<span class="stringliteral">"Unable to start the dump, %s\n"</span>, <a class="code" href="group__wpcapfunc.html#g81305cb154e4497e95bbb9b708631a3a">pcap_geterr</a>(fp));
            <span class="keywordflow">return</span> -1;
        }
    }
    <span class="keywordflow">else</span>{
        
        <span class="comment">/* 打开设备 */</span>
        <span class="keywordflow">if</span> ( (fp= <a class="code" href="group__wpcapfunc.html#gae6abe06e15c87b803f69773822beca8">pcap_open_live</a>(argv[1], 100, 1, 20, errbuf) ) == NULL)
        {
            fprintf(stderr,<span class="stringliteral">"\nError opening adapter\n"</span>);
            <span class="keywordflow">return</span> -1;
        }

        <span class="comment">/* 开始堆过程 */</span>
        <span class="keywordflow">if</span>(<a class="code" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump</a>(fp, argv[0], atoi(argv[1]), atoi(argv[2]))==-1){
            printf(<span class="stringliteral">"Unable to start the dump, %s\n"</span>, <a class="code" href="group__wpcapfunc.html#g81305cb154e4497e95bbb9b708631a3a">pcap_geterr</a>(fp));
            <span class="keywordflow">return</span> -1;
        }
    }

    <span class="comment">/* 等待，知道堆过程完成，也就是当数据到达max_size或max_packs的时候 */</span>
    <a class="code" href="group__wpcapfunc.html#gfe8a334f3a7ae2dc7f52e96523da39be">pcap_live_dump_ended</a>(fp, TRUE);
    
    <span class="comment">/* 关闭适配器，这样，就可以将数据立刻输出到文件了 */</span>
    <a class="code" href="group__wpcapfunc.html#ga45a5e1a4ba9925bb3586dcbeec78560">pcap_close</a>(fp);

    <span class="keywordflow">return</span> 0;
}
</pre>
</div>
<p> <a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a> 和 <a class="el" href="group__wpcapfunc.html#g659439bf5aa3988b5a92d31990fbf437">pcap_dump()</a>的区别，除了可以设置限制之外，就是运行结果。 <a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a> 利用了WinPcap NPF驱动自带的功能， (详情请参见 <a class="el" href="group__NPF.html">NPF驱动核心手册</a>) ，在内核级来写堆文件，并将上下文交换的数量和内存拷贝的数量最小化。<p>
显然，这个特性目前并不能应用于其它操作系统，因为 <a class="el" href="group__wpcapfunc.html#gedef54159d918b22a7de8e75b8a3ef4d">pcap_live_dump()</a> 是WinPcap的特性之一，并且只运行于Win32平台下。<p>
<a class="el" href="group__wpcap__tut6.html">&lt;&lt;&lt; 上一页</a> <a class="el" href="group__wpcap__tut8.html">下一页 &gt;&gt;&gt;</a> 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2005 Politecnico di Torino. Copyright (c) 2005-2007 
CACE Technologies. All rights reserved.
<br>2007 Translated By <a href="http://www.CoffeeCat.net.cn" target="_blank">CoffeeCat Studio</a>
</p>
