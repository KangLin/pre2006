<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>WinPcap: 发送数据包</title>
<link href="style.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<!-- Translation(Chinese) By CoffeeCat -->
<!-- http://www.CoffeeCat.net.cn-->
<div class="tabs">
  <ul>
    <li id="current"><a href="main.html"><span>主 页</span></a></li>
    <li><a href="modules.html"><span>模块</span></a></li>
    <li><a href="annotated.html"><span>数据结构</span></a></li>
    <li><a href="files.html"><span>文件</span></a></li>
    <li><a href="pages.html"><span>相关页面</span></a></li>
  </ul></div>
<h1>发送数据包</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
尽管从 <em>WinPcap</em> 的名字上看，这个库的目标应该是数据捕捉(Packet Capture)，然而，它也提供了针对很多其它有用的特性。在其中，我们可以找到一组很完整的用于发送数据包的函数。<p>
请注意：原始的libpcap库是不支持发送数据包的，因此，这里展示的函数都属于是WinPcap的扩展，并且它们不能运行于Unix平台下。<p>
<b>使用 <a class="el" href="group__wpcapfunc.html#g51dbda0f1ab9da2cfe49d657486d50b2">pcap_sendpacket()</a> 发送单个数据包</b><p>
下面的代码展示了发送一个数据包的最简单的方式。打开适配器以后，调用 <a class="el" href="group__wpcapfunc.html#g51dbda0f1ab9da2cfe49d657486d50b2">pcap_sendpacket()</a> 来发送手工制作的数据包。 <a class="el" href="group__wpcapfunc.html#g51dbda0f1ab9da2cfe49d657486d50b2">pcap_sendpacket()</a> 的参数有一个要包涵发送数据的缓冲区，缓冲的长度，以及用来发送数据的适配器。注意，缓冲数据将直接发送到网络，而不会进行任何加工和处理。这就意味着应用程序需要创建一个正确的协议首部，来使这个数据包更有意义。<p>
<div class="fragment">
  <pre class="fragment"><span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="preprocessor">#include &lt;pcap.h&gt;</span>


<span class="keywordtype">void</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
<a class="code" href="group__wpcap__def.html#g4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *fp;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#gcd448353957d92c98fccc29e1fc8d927">PCAP_ERRBUF_SIZE</a>];
u_char packet[100];
<span class="keywordtype">int</span> i;

    <span class="comment">/* 检查命令行参数的合法性 */</span>
    <span class="keywordflow">if</span> (argc != 2)
    {
        printf(<span class="stringliteral">"usage: %s interface (e.g. 'rpcap://eth0')"</span>, argv[0]);
        <span class="keywordflow">return</span>;
    }
    
    <span class="comment">/* 打开输出设备 */</span>
    <span class="keywordflow">if</span> ( (fp= <a class="code" href="group__wpcapfunc.html#g2b64c7b6490090d1d37088794f1f1791">pcap_open</a>(argv[1],            <span class="comment">// 设备名</span>
                        100,                <span class="comment">// 要捕获的部分 (只捕获前100个字节)</span>
                        <a class="code" href="group__remote__open__flags.html#g9134ce51a9a6a7d497c3dee5affdc3b9">PCAP_OPENFLAG_PROMISCUOUS</a>,  <span class="comment">// 混杂模式</span>
                        1000,               <span class="comment">// 读超时时间</span>
                        NULL,               <span class="comment">// 远程机器验证</span>
                        errbuf              <span class="comment">// 错误缓冲</span>
                        ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>, argv[1]);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* 假设在以太网上，设置MAC的目的地址为 1:1:1:1:1:1 */</span>
    packet[0]=1;
    packet[1]=1;
    packet[2]=1;
    packet[3]=1;
    packet[4]=1;
    packet[5]=1;
    
    <span class="comment">/* 设置MAC源地址为 2:2:2:2:2:2 */</span>
    packet[6]=2;
    packet[7]=2;
    packet[8]=2;
    packet[9]=2;
    packet[10]=2;
    packet[11]=2;
    
    <span class="comment">/* 填充剩下的内容 */</span>
    <span class="keywordflow">for</span>(i=12;i&lt;100;i++)
    {
        packet[i]=i%256;
    }

    <span class="comment">/* 发送数据包 */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#g51dbda0f1ab9da2cfe49d657486d50b2">pcap_sendpacket</a>(fp, packet, 100 <span class="comment">/* size */</span>) != 0)
    {
        fprintf(stderr,<span class="stringliteral">"\nError sending the packet: \n"</span>, <a class="code" href="group__wpcapfunc.html#g81305cb154e4497e95bbb9b708631a3a">pcap_geterr</a>(fp));
        <span class="keywordflow">return</span>;
    }

    <span class="keywordflow">return</span>;
}
</pre>
</div><p>
<b>发送队列</b><p>
<a class="el" href="group__wpcapfunc.html#g51dbda0f1ab9da2cfe49d657486d50b2">pcap_sendpacket()</a> 提供了一种简单而直接的方法来发送单个数据包，而 <b> send queues </b> 则提供了一种高级的，强大的，结构更优的方法来发送一组数据包。发送队列是一个容器，它能容纳不同数量的数据包，这些数据包将被发送到网络上。队列有大小，它代表了它能存储的数据包的最大数量。
<p>
发送队列通过调用 <a class="el" href="group__wpcapfunc.html#gb940e69631b7cc7f2232a69ea02b86d9">pcap_sendqueue_alloc()</a> 函数创建，并且需要指定队列的大小。
<p>
一旦发送队列被创建， <a class="el" href="group__wpcapfunc.html#g4c57ea320d71dbfe55c5665af9db1297">pcap_sendqueue_queue()</a> 就可以将数据包添加到发送队列中。这个函数的参数包含一个 <a class="el" href="structpcap__pkthdr.html">pcap_pkthdr</a> 的结构体，它包含时间戳和长度，同时，参数还包含一个指向数据包数据的缓冲。这些参数和那些被 <a class="el" href="group__wpcapfunc.html#g439439c2eae61161dc1efb1e03a81133">pcap_next_ex()</a> 和 <a class="el" href="group__wpcapfunc.html#gc429cf4f27205111259ff7b02a82eeab">pcap_handler()</a>接收到的数据相同，因此，为那些刚刚捕获到的，或是从文件读取出来的数据包排队，就相当于把三个参数传递给 <a class="el" href="group__wpcapfunc.html#g4c57ea320d71dbfe55c5665af9db1297">pcap_sendqueue_queue()</a> 。 
<p>
WinPcap提供了 <a class="el" href="group__wpcapfunc.html#ga4d55eb047a1cccc0e28397ce04ee097">pcap_sendqueue_transmit()</a> 函数来发送一个队列。请注意第三个参数：如果非零，那么发送过程将是同步进行，也就是说，只有时间戳相符的数据包才会被处理。这个操作需要消耗大量的CPU资源，因为同步操作由内核驱动中的"忙等 (busy wait)"循环来实现的。尽管这个操作对CPU的要求很高，但它对包传送的处理结果，通常是很精确的。(通常在数微秒左右，或更小)<p>
请注意，使用 <a class="el" href="group__wpcapfunc.html#ga4d55eb047a1cccc0e28397ce04ee097">pcap_sendqueue_transmit()</a> 要比 <a class="el" href="group__wpcapfunc.html#g51dbda0f1ab9da2cfe49d657486d50b2">pcap_sendpacket()</a> 来发送一系列数据更加有效率，因为发送队列保存在内核级的缓冲区，因此，减少了上下文交换的次数。<p>
当队列不再需要时，我们可以使用 <a class="el" href="group__wpcapfunc.html#g72624f7a9932cc2124abf661001e0aa4">pcap_sendqueue_destroy()</a> 来释放它所占用的内存。<p>
下一个程序将演示如何使用发送队列。先用 <a class="el" href="group__wpcapfunc.html#g91078168a13de8848df2b7b83d1f5b69">pcap_open_offline()</a> 打开一个捕获文件，然后，将文件中的数据包移到已分配的发送队列。这时，就可以发送队列了，如果用户指定了同步，那么它将同步发送队列。<p>
注意，堆文件的链路层将会那些发送数据包接口中的一个进行比较，那些接口使用 <a class="el" href="group__wpcapfunc.html#g64c019f851f7da6892d51cca15f12ace">pcap_datalink()</a> 发送数据包。当比较的结果不相同，那么就会打印出警告信息。捕获文件的链路层和适配器的链路层相一致是非常重要的，不然，发送将变得毫无意义。<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)</span>
<span class="comment"> * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)</span>
<span class="comment"> * All rights reserved.</span>
<span class="comment"> *</span>
<span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<span class="comment"> * modification, are permitted provided that the following conditions</span>
<span class="comment"> * are met:</span>
<span class="comment"> *</span>
<span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
<span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="comment"> * notice, this list of conditions and the following disclaimer in the</span>
<span class="comment"> * documentation and/or other materials provided with the distribution.</span>
<span class="comment"> * 3. Neither the name of the Politecnico di Torino, CACE Technologies </span>
<span class="comment"> * nor the names of its contributors may be used to endorse or promote </span>
<span class="comment"> * products derived from this software without specific prior written </span>
<span class="comment"> * permission.</span>
<span class="comment"> *</span>
<span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="comment"> *</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="preprocessor">#include &lt;pcap.h&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="remote-ext_8h.html">remote-ext.h</a>&gt;</span>

<span class="keywordtype">void</span> usage();

<span class="keywordtype">void</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
    <a class="code" href="group__wpcap__def.html#g4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *indesc,*outdesc;
    <span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#gcd448353957d92c98fccc29e1fc8d927">PCAP_ERRBUF_SIZE</a>];
    <span class="keywordtype">char</span> source[<a class="code" href="group__remote__struct.html#gcacb155b596f7511f714de129ae32c97">PCAP_BUF_SIZE</a>];
    FILE *capfile;
    <span class="keywordtype">int</span> <a class="code" href="structpcap__pkthdr.html#ac5771ed2efd92508bb4fe650f2ce7d7">caplen</a>, sync;
    u_int res;
    <a class="code" href="structpcap__send__queue.html">pcap_send_queue</a> *squeue;
    <span class="keyword">struct </span><a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *pktheader;
    u_char *pktdata;
    <span class="keywordtype">float</span> cpu_time;
    u_int npacks = 0;
    
    <span class="comment">/* 检查命令行参数的合法性 */</span>
    <span class="keywordflow">if</span> (argc &lt;= 2 || argc &gt;= 5)
    {
        usage();
        <span class="keywordflow">return</span>;
    }
        
    <span class="comment">/* 获取捕获文件长度 */</span>
    capfile=fopen(argv[1],<span class="stringliteral">"rb"</span>);
    <span class="keywordflow">if</span>(!capfile){
        printf(<span class="stringliteral">"Capture file not found!\n"</span>);
        <span class="keywordflow">return</span>;
    }
    
    fseek(capfile , 0, SEEK_END);
    caplen= ftell(capfile)- <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structpcap__file__header.html">pcap_file_header</a>);
    fclose(capfile);
            
    <span class="comment">/* 检查时间戳是否合法 */</span>
    <span class="keywordflow">if</span>(argc == 4 &amp;&amp; argv[3][0] == <span class="charliteral">'s'</span>)
        sync = TRUE;
    <span class="keywordflow">else</span>
        sync = FALSE;

    <span class="comment">/* 开始捕获 */</span>
    <span class="comment">/* 根据WinPcap的新语法创建一个源字符串 */</span>
    <span class="keywordflow">if</span> ( <a class="code" href="group__wpcapfunc.html#ga3111e10f930a9772a32a922b26948b0">pcap_createsrcstr</a>( source,         <span class="comment">// 源字符串</span>
                            <a class="code" href="group__remote__source__ID.html#g9188ad0fc0d12fc51d1e9f5e78bf9440">PCAP_SRC_FILE</a>,  <span class="comment">// 我们要打开的文件</span>
                            NULL,           <span class="comment">// 远程主机</span>
                            NULL,           <span class="comment">// 远程主机的端口</span>
                            argv[1],        <span class="comment">// 我们要打开的文件名</span>
                            errbuf          <span class="comment">// 错误缓冲</span>
                            ) != 0)
    {
        fprintf(stderr,<span class="stringliteral">"\nError creating a source string\n"</span>);
        <span class="keywordflow">return</span>;
    }
    
    <span class="comment">/* 打开捕获文件 */</span>
    <span class="keywordflow">if</span> ( (indesc= <a class="code" href="group__wpcapfunc.html#g2b64c7b6490090d1d37088794f1f1791">pcap_open</a>(source, 65536, <a class="code" href="group__remote__open__flags.html#g9134ce51a9a6a7d497c3dee5affdc3b9">PCAP_OPENFLAG_PROMISCUOUS</a>, 1000, NULL, errbuf) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the file %s.\n"</span>, source);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* 打开要输出的适配器 */</span>
    <span class="keywordflow">if</span> ( (outdesc= <a class="code" href="group__wpcapfunc.html#g2b64c7b6490090d1d37088794f1f1791">pcap_open</a>(argv[2], 100, <a class="code" href="group__remote__open__flags.html#g9134ce51a9a6a7d497c3dee5affdc3b9">PCAP_OPENFLAG_PROMISCUOUS</a>, 1000, NULL, errbuf) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open adapter %s.\n"</span>, source);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* 检查MAC的类型 */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#g64c019f851f7da6892d51cca15f12ace">pcap_datalink</a>(indesc) != <a class="code" href="group__wpcapfunc.html#g64c019f851f7da6892d51cca15f12ace">pcap_datalink</a>(outdesc))
    {
        printf(<span class="stringliteral">"Warning: the datalink of the capture differs from the one of the selected interface.\n"</span>);
        printf(<span class="stringliteral">"Press a key to continue, or CTRL+C to stop.\n"</span>);
        getchar();
    }

    <span class="comment">/* 分配发送队列 */</span>
    squeue = <a class="code" href="group__wpcapfunc.html#gb940e69631b7cc7f2232a69ea02b86d9">pcap_sendqueue_alloc</a>(caplen);

    <span class="comment">/* 从文件中将数据包填充到发送队列 */</span>
    <span class="keywordflow">while</span> ((res = <a class="code" href="group__wpcapfunc.html#g439439c2eae61161dc1efb1e03a81133">pcap_next_ex</a>( indesc, &amp;pktheader, &amp;pktdata)) == 1)
    {
        <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#g4c57ea320d71dbfe55c5665af9db1297">pcap_sendqueue_queue</a>(squeue, pktheader, pktdata) == -1)
        {
            printf(<span class="stringliteral">"Warning: packet buffer too small, not all the packets will be sent.\n"</span>);
            <span class="keywordflow">break</span>;
        }

        npacks++;
    }

    <span class="keywordflow">if</span> (res == -1)
    {
        printf(<span class="stringliteral">"Corrupted input file.\n"</span>);
        <a class="code" href="group__wpcapfunc.html#g72624f7a9932cc2124abf661001e0aa4">pcap_sendqueue_destroy</a>(squeue);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* 发送队列 */</span>
    
    cpu_time = (float)clock ();

    <span class="keywordflow">if</span> ((res = <a class="code" href="group__wpcapfunc.html#ga4d55eb047a1cccc0e28397ce04ee097">pcap_sendqueue_transmit</a>(outdesc, squeue, sync)) &lt; squeue-&gt;<a class="code" href="structpcap__send__queue.html#b4853420730b2b590cd3ad0e72fa80ca">len</a>)
    {
        printf(<span class="stringliteral">"An error occurred sending the packets: %s. Only %d bytes were sent\n"</span>, <a class="code" href="group__wpcapfunc.html#g81305cb154e4497e95bbb9b708631a3a">pcap_geterr</a>(outdesc), res);
    }
    
    cpu_time = (clock() - cpu_time)/CLK_TCK;
    
    printf (<span class="stringliteral">"\n\nElapsed time: %5.3f\n"</span>, cpu_time);
    printf (<span class="stringliteral">"\nTotal packets generated = %d"</span>, npacks);
    printf (<span class="stringliteral">"\nAverage packets per second = %d"</span>, (<span class="keywordtype">int</span>)((<span class="keywordtype">double</span>)npacks/cpu_time));
    printf (<span class="stringliteral">"\n"</span>);

    <span class="comment">/* 释放发送队列 */</span>
    <a class="code" href="group__wpcapfunc.html#g72624f7a9932cc2124abf661001e0aa4">pcap_sendqueue_destroy</a>(squeue);

    <span class="comment">/* 关闭输入文件 */</span>
    <a class="code" href="group__wpcapfunc.html#ga45a5e1a4ba9925bb3586dcbeec78560">pcap_close</a>(indesc);

    <span class="comment">/* </span>
<span class="comment">     * 释放输出适配器 </span>
<span class="comment">     * IMPORTANT: 记得一定要关闭适配器，不然就不能保证 </span>
<span class="comment">     * 所有的数据包都回被发送出去</span>
<span class="comment">     */</span>
    <a class="code" href="group__wpcapfunc.html#ga45a5e1a4ba9925bb3586dcbeec78560">pcap_close</a>(outdesc);


    <span class="keywordflow">return</span>;
}


<span class="keywordtype">void</span> usage()
{
    
    printf(<span class="stringliteral">"\nSendcap, sends a libpcap/tcpdump capture file to the net. Copyright (C) 2002 Loris Degioanni.\n"</span>);
    printf(<span class="stringliteral">"\nUsage:\n"</span>);
    printf(<span class="stringliteral">"\t sendcap file_name adapter [s]\n"</span>);
    printf(<span class="stringliteral">"\nParameters:\n"</span>);
    printf(<span class="stringliteral">"\nfile_name: the name of the dump file that will be sent to the network\n"</span>);
    printf(<span class="stringliteral">"\nadapter: the device to use. Use \"WinDump -D\" for a list of valid devices\n"</span>);
    printf(<span class="stringliteral">"\ns: if present, forces the packets to be sent synchronously, i.e. respecting the timestamps in the dump file. This option will work only under Windows NTx.\n\n"</span>);

    exit(0);
}
</pre></div><p>
<a class="el" href="group__wpcap__tut7.html">&lt;&lt;&lt; 上一页</a> <a class="el" href="group__wpcap__tut9.html">下一页 &gt;&gt;&gt;</a> 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2005 Politecnico di Torino. Copyright (c) 2005-2007 
CACE Technologies. All rights reserved.
<br>2007 Translated By <a href="http://www.CoffeeCat.net.cn" target="_blank">CoffeeCat Studio</a>
</p>
