<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>WinPcap: 收集并统计网络流量</title>
<link href="style.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<!-- http://www.CoffeeCat.net.cn-->
<div class="tabs">
  <ul>
    <li id="current"><a href="main.html"><span>主 页</span></a></li>
    <li><a href="modules.html"><span>模块</span></a></li>
    <li><a href="annotated.html"><span>数据结构</span></a></li>
    <li><a href="files.html"><span>文件</span></a></li>
    <li><a href="pages.html"><span>相关页面</span></a></li>
  </ul></div>
<h1>收集并统计网络流量</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
这一讲，我们将展示WinPcap的另一个高级特性：收集并统计网络流量。统计引擎利用了内核级的数据包过滤器，来有效地为收集到的数据包进行分类。如果你想阅读更多细节，请参阅 <a class="el" href="group__NPF.html">NPF驱动核心手册</a>。<p>
为了使用这个特性，编程人员必须打开一个适配器，并且，可以使用 <a class="el" href="group__wpcapfunc.html#gef07ef49d3c75644f3fd34518e2fe720">pcap_setmode()</a> 将它设置为统计模式(<em>statistical mode</em>)。特别注意，必须使用MODE_STAT来作为这个函数的mode参数。<p>
在统计模式下，编写一个用于监听TCP网络流量的程序并不复杂，代码也不多。下面的范例程序将展示如何实现这个程序。<p>
<div class="fragment">
  <pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)</span>
<span class="comment"> * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)</span>
<span class="comment"> * All rights reserved.</span>
<span class="comment"> *</span>
<span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<span class="comment"> * modification, are permitted provided that the following conditions</span>
<span class="comment"> * are met:</span>
<span class="comment"> *</span>
<span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
<span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="comment"> * notice, this list of conditions and the following disclaimer in the</span>
<span class="comment"> * documentation and/or other materials provided with the distribution.</span>
<span class="comment"> * 3. Neither the name of the Politecnico di Torino, CACE Technologies </span>
<span class="comment"> * nor the names of its contributors may be used to endorse or promote </span>
<span class="comment"> * products derived from this software without specific prior written </span>
<span class="comment"> * permission.</span>
<span class="comment"> *</span>
<span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="comment"> *</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="preprocessor">#include &lt;pcap.h&gt;</span>

<span class="keywordtype">void</span> usage();

<span class="keywordtype">void</span> dispatcher_handler(u_char *, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *, <span class="keyword">const</span> u_char *);


<span class="keywordtype">void</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
<a class="code" href="group__wpcap__def.html#g4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *fp;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#gcd448353957d92c98fccc29e1fc8d927">PCAP_ERRBUF_SIZE</a>];
<span class="keyword">struct </span>timeval st_ts;
u_int netmask;
<span class="keyword">struct </span>bpf_program fcode;
  
    <span class="comment">/* 检查命令行参数的合法性 */</span>
    <span class="keywordflow">if</span> (argc != 2)
    {
        usage();
        <span class="keywordflow">return</span>;
    }
        
    <span class="comment">/* 打开输出适配器 */</span>
    <span class="keywordflow">if</span> ( (fp= <a class="code" href="group__wpcapfunc.html#g2b64c7b6490090d1d37088794f1f1791">pcap_open</a>(argv[1], 100, <a class="code" href="group__remote__open__flags.html#g9134ce51a9a6a7d497c3dee5affdc3b9">PCAP_OPENFLAG_PROMISCUOUS</a>, 1000, NULL, errbuf) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open adapter %s.\n"</span>, errbuf);
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* 不用关心掩码，在这个过滤器中，它不会被使用 */</span>
    netmask=0xffffff; 

    <span class="comment">// 编译过滤器</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#g363bdc6f6b39b4979ddcf15ecb830c5c">pcap_compile</a>(fp, &amp;fcode, <span class="stringliteral">"tcp"</span>, 1, netmask) &lt;0 )
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to compile the packet filter. Check the syntax.\n"</span>);
        <span class="comment">/* 释放设备列表 */</span>
        <span class="keywordflow">return</span>;
    }
    
    <span class="comment">//设置过滤器</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#gf5f9cfe85dad0967ff607e5159b1ba61">pcap_setfilter</a>(fp, &amp;fcode)&lt;0)
    {
        fprintf(stderr,<span class="stringliteral">"\nError setting the filter.\n"</span>);
        <a class="code" href="group__wpcapfunc.html#ga45a5e1a4ba9925bb3586dcbeec78560">pcap_close</a>(fp);
        <span class="comment">/* 释放设备列表 */</span>
        <span class="keywordflow">return</span>;
    }

    <span class="comment">/* 将接口设置为统计模式 */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#gef07ef49d3c75644f3fd34518e2fe720">pcap_setmode</a>(fp, <a class="code" href="group__NPF__include.html#g503326906a62e96c147ae6af31fb5659">MODE_STAT</a>)&lt;0)
    {
        fprintf(stderr,<span class="stringliteral">"\nError setting the mode.\n"</span>);
        <a class="code" href="group__wpcapfunc.html#ga45a5e1a4ba9925bb3586dcbeec78560">pcap_close</a>(fp);
        <span class="comment">/* 释放设备列表 */</span>
        <span class="keywordflow">return</span>;
    }


    printf(<span class="stringliteral">"TCP traffic summary:\n"</span>);

    <span class="comment">/* 开始主循环 */</span>
    <a class="code" href="group__wpcapfunc.html#g6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop</a>(fp, 0, dispatcher_handler, (PUCHAR)&amp;st_ts);

    <a class="code" href="group__wpcapfunc.html#ga45a5e1a4ba9925bb3586dcbeec78560">pcap_close</a>(fp);
    <span class="keywordflow">return</span>;
}

<span class="keywordtype">void</span> dispatcher_handler(u_char *state, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    <span class="keyword">struct </span>timeval *old_ts = (<span class="keyword">struct </span>timeval *)state;
    u_int delay;
    LARGE_INTEGER Bps,Pps;
    <span class="keyword">struct </span>tm *ltime;
    <span class="keywordtype">char</span> timestr[16];
    time_t local_tv_sec;

    <span class="comment">/* 以毫秒计算上一次采样的延迟时间 */</span>
    <span class="comment">/* 这个值通过采样到的时间戳获得 */</span>
    delay=(header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_sec - old_ts-&gt;tv_sec) * 1000000 - old_ts-&gt;tv_usec + header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_usec;
    <span class="comment">/* 获取每秒的比特数b/s */</span>
    Bps.QuadPart=(((*(LONGLONG*)(pkt_data + 8)) * 8 * 1000000) / (delay));
    <span class="comment">/*                                            ^      ^</span>
<span class="comment">                                                  |      |</span>
<span class="comment">                                                  |      | </span>
<span class="comment">                                                  |      |</span>
<span class="comment">                              将字节转换成比特 --   |</span>
<span class="comment">                                                         |</span>
<span class="comment">                                       延时是以毫秒表示的 --</span>
<span class="comment">    */</span>

    <span class="comment">/* 得到每秒的数据包数量 */</span>
    Pps.QuadPart=(((*(LONGLONG*)(pkt_data)) * 1000000) / (delay));

    <span class="comment">/* 将时间戳转化为可识别的格式 */</span>
    local_tv_sec = header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_sec;
    ltime=localtime(&amp;local_tv_sec);
    strftime( timestr, <span class="keyword">sizeof</span> timestr, <span class="stringliteral">"%H:%M:%S"</span>, ltime);

    <span class="comment">/* 打印时间戳*/</span>
    printf(<span class="stringliteral">"%s "</span>, timestr);

    <span class="comment">/* 打印采样结果 */</span>
    printf(<span class="stringliteral">"BPS=%I64u "</span>, Bps.QuadPart);
    printf(<span class="stringliteral">"PPS=%I64u\n"</span>, Pps.QuadPart);

    <span class="comment">//存储当前的时间戳</span>
    old_ts-&gt;tv_sec=header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_sec;
    old_ts-&gt;tv_usec=header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_usec;
}


<span class="keywordtype">void</span> usage()
{
    
    printf(<span class="stringliteral">"\nShows the TCP traffic load, in bits per second and packets per second.\nCopyright (C) 2002 Loris Degioanni.\n"</span>);
    printf(<span class="stringliteral">"\nUsage:\n"</span>);
    printf(<span class="stringliteral">"\t tcptop adapter\n"</span>);
    printf(<span class="stringliteral">"\t You can use \"WinDump -D\" if you don't know the name of your adapters.\n"</span>);

    exit(0);
}
</pre>
</div><p>
在启动统计模式前，用户需要设置一个过滤器，以定义要监听的数据流。详细内容请参考 <a class="el" href="group__language.html">过滤表达式语法</a> 。如果没有设置过滤器，那么，所有的数据流量都将会被监听<p>
过程<p>
<ul>
<li>设置过滤器</li><li>调用 <a class="el" href="group__wpcapfunc.html#gef07ef49d3c75644f3fd34518e2fe720">pcap_setmode()</a></li><li>回调函数通过 <a class="el" href="group__wpcapfunc.html#g6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop()</a>被启动</li></ul>
<p>
接口描述符(the interface descriptor)开始工作在统计模式下。注意 <a class="el" href="group__wpcapfunc.html#g2b64c7b6490090d1d37088794f1f1791">pcap_open()</a> 函数的第4个参数( <em>to_ms</em> )：它定义了统计残阳的时间间隔。回调函数将在每一个<em>to_ms</em>时间，收到由驱动发来的计算好的采样数据。这些采样数据将通过回调函数的第2个和第3个参数传递，如下所示<p>
<div align="center">
<img src="stats_wpcap.gif" alt="stats_wpcap.gif">
</div>
<p>
它提供了两个64位的计数器，分别记录在最后一个时间间隔内，收到的数据包的数量和字节总数。<p>
在这个范例中，适配器打开后的超时时间设置为1000毫秒。这就意味着dispatcher_handler()每隔1秒就会被调用一次。这里的过滤器被设置为只监视TCP包。然后， <a class="el" href="group__wpcapfunc.html#gef07ef49d3c75644f3fd34518e2fe720">pcap_setmode()</a> 和 <a class="el" href="group__wpcapfunc.html#g6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop()</a> 被调用。注意，一个指向timeval结构的指针，作为<em>user</em>参数传递给函数 <a class="el" href="group__wpcapfunc.html#g6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop()</a> 。这个结构体会被用来存储时间戳，以便计算两次采样的时间间隔。 dispatcher_handler() 会使用这个时间间隔来获得每秒的比特数(bps)以及每秒的数据包数量(pps)，并将它们的值打印在屏幕上。<p>
最后，我们想说，这个范例程序比传统的捕获和统计流量的程序都要高效，因为传统的程序都在用户层进行。静态模式需要最小的数据包拷贝和上下文交换，因此，CPU的性能会最优，而且，内存的需求量也会很少。<p>
<a class="el" href="group__wpcap__tut8.html">&lt;&lt;&lt; 上一页</a> 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2005 Politecnico di Torino. Copyright (c) 2005-2007 
CACE Technologies. All rights reserved.
<br>2007 Translated By <a href="http://www.CoffeeCat.net.cn" target="_blank">CoffeeCat Studio</a>
</p>
