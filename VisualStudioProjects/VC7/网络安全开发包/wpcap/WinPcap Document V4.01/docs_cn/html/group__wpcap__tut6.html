<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>WinPcap: 分析数据包</title>
<link href="style.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<!-- Translation(Chinese) By CoffeeCat -->
<!-- http://www.CoffeeCat.net.cn-->
<div class="tabs">
  <ul>
    <li id="current"><a href="main.html"><span>主 页</span></a></li>
    <li><a href="modules.html"><span>模块</span></a></li>
    <li><a href="annotated.html"><span>数据结构</span></a></li>
    <li><a href="files.html"><span>文件</span></a></li>
    <li><a href="pages.html"><span>相关页面</span></a></li>
  </ul></div>
<h1>分析数据包</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
现在，我们可以捕捉并过滤网络流量了，那就让我们学以致用，来做一个简单使用的程序吧。<p>
在本讲中，我们将会利用上一讲的一些代码，来建立一个更实用的程序。 本程序的主要目标是展示如何解析所捕获的数据包的协议首部。这个程序可以称为UDPdump，打印一些网络上传输的UDP数据的信息。 
<p>
我们选择分析和现实UDP协议而不是TCP等其它协议，是因为它比其它的协议更简单，作为一个入门程序范例，是很不错的选择。让我们看看代码：<p>
<div class="fragment">
  <pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright (c) 1999 - 2005 NetGroup, Politecnico di Torino (Italy)</span>
<span class="comment"> * Copyright (c) 2005 - 2006 CACE Technologies, Davis (California)</span>
<span class="comment"> * All rights reserved.</span>
<span class="comment"> *</span>
<span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<span class="comment"> * modification, are permitted provided that the following conditions</span>
<span class="comment"> * are met:</span>
<span class="comment"> *</span>
<span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="comment"> * notice, this list of conditions and the following disclaimer.</span>
<span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="comment"> * notice, this list of conditions and the following disclaimer in the</span>
<span class="comment"> * documentation and/or other materials provided with the distribution.</span>
<span class="comment"> * 3. Neither the name of the Politecnico di Torino, CACE Technologies </span>
<span class="comment"> * nor the names of its contributors may be used to endorse or promote </span>
<span class="comment"> * products derived from this software without specific prior written </span>
<span class="comment"> * permission.</span>
<span class="comment"> *</span>
<span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="comment"> * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="comment"> *</span>
<span class="comment"> */</span>

<span class="preprocessor">#include "pcap.h"</span>

<span class="comment">/* 4字节的IP地址 */</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>ip_address{
    u_char byte1;
    u_char byte2;
    u_char byte3;
    u_char byte4;
}ip_address;

<span class="comment">/* IPv4 首部 */</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>ip_header{
    u_char  ver_ihl;        <span class="comment">// 版本 (4 bits) + 首部长度 (4 bits)</span>
    u_char  tos;            <span class="comment">// 服务类型(Type of service) </span>
    u_short tlen;           <span class="comment">// 总长(Total length) </span>
    u_short identification; <span class="comment">// 标识(Identification)</span>
    u_short flags_fo;       <span class="comment">// 标志位(Flags) (3 bits) + 段偏移量(Fragment offset) (13 bits)</span>
    u_char  ttl;            <span class="comment">// 存活时间(Time to live</span>)
    u_char  proto;          <span class="comment">// 协议(Protocol</span>)
    u_short crc;            <span class="comment">// 首部校验和(Header checksum)</span>
    ip_address  saddr;      <span class="comment">// 源地址(Source address)</span>
    ip_address  daddr;      <span class="comment">// 目的地址(Destination address)</span>
    u_int   op_pad;         <span class="comment">// 选项与填充(Option + Padding)</span>
}ip_header;

<span class="comment">/* UDP 首部*/</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>udp_header{
    u_short sport;          <span class="comment">// 源端口(Source port)</span>
    u_short dport;          <span class="comment">// 目的端口(Destination port)</span>
    u_short len;            <span class="comment">// UDP数据包长度(Datagram length)</span>
    u_short crc;            <span class="comment">// 校验和(Checksum)</span>
}udp_header;

<span class="comment">/* 回调函数原型 */</span>
<span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data);


main()
{
<a class="code" href="structpcap__if.html">pcap_if_t</a> *alldevs;
<a class="code" href="structpcap__if.html">pcap_if_t</a> *d;
<span class="keywordtype">int</span> inum;
<span class="keywordtype">int</span> i=0;
<a class="code" href="group__wpcap__def.html#g4711d025f83503ce692efa5e45ec60a7">pcap_t</a> *adhandle;
<span class="keywordtype">char</span> errbuf[<a class="code" href="group__wpcap__def.html#gcd448353957d92c98fccc29e1fc8d927">PCAP_ERRBUF_SIZE</a>];
u_int netmask;
<span class="keywordtype">char</span> packet_filter[] = <span class="stringliteral">"ip and udp"</span>;
<span class="keyword">struct </span>bpf_program fcode;

    <span class="comment">/* 获得设备列表 */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#g98f36e62c95c6ad81eaa8b2bbeb8f16e">pcap_findalldevs_ex</a>(<a class="code" href="group__remote__source__string.html#g6d7103b8a7e1eca8c325bd8f32c361c3">PCAP_SRC_IF_STRING</a>, NULL, &amp;alldevs, errbuf) == -1)
    {
        fprintf(stderr,<span class="stringliteral">"Error in pcap_findalldevs: %s\n"</span>, errbuf);
        exit(1);
    }
    
    <span class="comment">/* 打印列表 */</span>
    <span class="keywordflow">for</span>(d=alldevs; d; d=d-&gt;<a class="code" href="structpcap__if.html#81508e6e4e41ca4235c8d6b51913c536">next</a>)
    {
        printf(<span class="stringliteral">"%d. %s"</span>, ++i, d-&gt;<a class="code" href="structpcap__if.html#5ac083a645d964373f022d03df4849c8">name</a>);
        if (d-&gt;<a class="code" href="structpcap__if.html#8444d6e0dfe2bbab0b5e7b24308f1559">description</a>)
            printf(<span class="stringliteral">" (%s)\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#8444d6e0dfe2bbab0b5e7b24308f1559">description</a>);
        <span class="keywordflow">else</span>
            printf(<span class="stringliteral">" (No description available)\n"</span>);
    }

    <span class="keywordflow">if</span>(i==0)
    {
        printf(<span class="stringliteral">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"Enter the interface number (1-%d):"</span>,i);
    scanf(<span class="stringliteral">"%d"</span>, &amp;inum);
    
    <span class="keywordflow">if</span>(inum &lt; 1 || inum &gt; i)
    {
        printf(<span class="stringliteral">"\nInterface number out of range.\n"</span>);
        <span class="comment">/* 释放设备列表 */</span>
        <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }

    <span class="comment">/* 跳转到已选设备 */</span>
    <span class="keywordflow">for</span>(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;<a class="code" href="structpcap__if.html#81508e6e4e41ca4235c8d6b51913c536">next</a>, i++);
    
    <span class="comment">/* 打开适配器 */</span>
    <span class="keywordflow">if</span> ( (adhandle= <a class="code" href="group__wpcapfunc.html#g2b64c7b6490090d1d37088794f1f1791">pcap_open</a>(d-&gt;<a class="code" href="structpcap__if.html#5ac083a645d964373f022d03df4849c8">name</a>,  <span class="comment">// 设备名</span>
                             65536,     <span class="comment">// 要捕捉的数据包的部分 </span>
                                        <span class="comment">// 65535保证能捕获到不同数据链路层上的每个数据包的全部内容</span>
                             <a class="code" href="group__remote__open__flags.html#g9134ce51a9a6a7d497c3dee5affdc3b9">PCAP_OPENFLAG_PROMISCUOUS</a>,         <span class="comment">// 混杂模式</span>
                             1000,      <span class="comment">// 读取超时时间</span>
                             NULL,      <span class="comment">// 远程机器验证</span>
                             errbuf     <span class="comment">// 错误缓冲池</span>
                             ) ) == NULL)
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>);
        <span class="comment">/* 释放设备列表 */</span>
        <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">/* 检查数据链路层，为了简单，我们只考虑以太网 */</span>
    <span class="keywordflow">if</span>(<a class="code" href="group__wpcapfunc.html#g64c019f851f7da6892d51cca15f12ace">pcap_datalink</a>(adhandle) != DLT_EN10MB)
    {
        fprintf(stderr,<span class="stringliteral">"\nThis program works only on Ethernet networks.\n"</span>);
        <span class="comment">/* 释放设备列表 */</span>
        <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="keywordflow">if</span>(d-&gt;<a class="code" href="structpcap__if.html#3910004677550db6d9b09792ba3e2cca">addresses</a> != NULL)
        <span class="comment">/* 获得接口第一个地址的掩码 */</span>
        netmask=((<span class="keyword">struct </span>sockaddr_in *)(d-&gt;<a class="code" href="structpcap__if.html#3910004677550db6d9b09792ba3e2cca">addresses</a>-&gt;<a class="code" href="structpcap__addr.html#c43963e42e4d901e55e433ab9c3ea686">netmask</a>))-&gt;sin_addr.S_un.S_addr;
    <span class="keywordflow">else</span>
        <span class="comment">/* 如果接口没有地址，那么我们假设一个C类的掩码 */</span>
        netmask=0xffffff; 


    <span class="comment">//编译过滤器</span>
    if (<a class="code" href="group__wpcapfunc.html#g363bdc6f6b39b4979ddcf15ecb830c5c">pcap_compile</a>(adhandle, &amp;fcode, packet_filter, 1, netmask) &lt;0 )
    {
        fprintf(stderr,<span class="stringliteral">"\nUnable to compile the packet filter. Check the syntax.\n"</span>);
        <span class="comment">/* 释放设备列表 */</span>
        <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    <span class="comment">//设置过滤器</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__wpcapfunc.html#gf5f9cfe85dad0967ff607e5159b1ba61">pcap_setfilter</a>(adhandle, &amp;fcode)&lt;0)
    {
        fprintf(stderr,<span class="stringliteral">"\nError setting the filter.\n"</span>);
        <span class="comment">/* 释放设备列表 */</span>
        <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);
        <span class="keywordflow">return</span> -1;
    }
    
    printf(<span class="stringliteral">"\nlistening on %s...\n"</span>, d-&gt;<a class="code" href="structpcap__if.html#8444d6e0dfe2bbab0b5e7b24308f1559">description</a>);
    
    <span class="comment">/* 释放设备列表 */</span>
    <a class="code" href="group__wpcapfunc.html#g346b4b0b7fd1cda4abb9a39f767dbeb1">pcap_freealldevs</a>(alldevs);
    
    <span class="comment">/* 开始捕捉 */</span>
    <a class="code" href="group__wpcapfunc.html#g6bcb7c5c59d76ec16b8a699da136b5de">pcap_loop</a>(adhandle, 0, packet_handler, NULL);
    
    <span class="keywordflow">return</span> 0;
}

<span class="comment">/* 回调函数，当收到每一个数据包时会被libpcap所调用 */</span>
<span class="keywordtype">void</span> packet_handler(u_char *param, <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structpcap__pkthdr.html">pcap_pkthdr</a> *header, <span class="keyword">const</span> u_char *pkt_data)
{
    <span class="keyword">struct </span>tm *ltime;
    <span class="keywordtype">char</span> timestr[16];
    ip_header *ih;
    udp_header *uh;
    u_int ip_len;
    u_short sport,dport;
    time_t local_tv_sec;

    <span class="comment">/* 将时间戳转换成可识别的格式 */</span>
    local_tv_sec = header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_sec;
    ltime=localtime(&amp;local_tv_sec);
    strftime( timestr, <span class="keyword">sizeof</span> timestr, <span class="stringliteral">"%H:%M:%S"</span>, ltime);

    <span class="comment">/* 打印数据包的时间戳和长度 */</span>
    printf(<span class="stringliteral">"%s.%.6d len:%d "</span>, timestr, header-&gt;<a class="code" href="structpcap__pkthdr.html#21be78b2818c91cb205885b8a6f5aed8">ts</a>.tv_usec, header-&gt;<a class="code" href="structpcap__pkthdr.html#728f264db4f5cc304742565a2bcdbeea">len</a>);

    <span class="comment">/* 获得IP数据包头部的位置 */</span>
    ih = (ip_header *) (pkt_data +
        14); <span class="comment">//以太网头部长度</span>

    <span class="comment">/* 获得UDP首部的位置 */</span>
    ip_len = (ih-&gt;ver_ihl &amp; 0xf) * 4;
    uh = (udp_header *) ((u_char*)ih + ip_len);

    <span class="comment">/* 将网络字节序列转换成主机字节序列 */</span>
    sport = ntohs( uh-&gt;sport );
    dport = ntohs( uh-&gt;dport );

    <span class="comment">/* 打印IP地址和UDP端口 */</span>
    printf(<span class="stringliteral">"%d.%d.%d.%d.%d -&gt; %d.%d.%d.%d.%d\n"</span>,
        ih-&gt;saddr.byte1,
        ih-&gt;saddr.byte2,
        ih-&gt;saddr.byte3,
        ih-&gt;saddr.byte4,
        sport,
        ih-&gt;daddr.byte1,
        ih-&gt;daddr.byte2,
        ih-&gt;daddr.byte3,
        ih-&gt;daddr.byte4,
        dport);
}
</pre>
</div><p>
首先，我们将过滤器设置成"ip and udp"。在这种方式下，我们确信packet_handler()只会收到基于IPv4的UDP数据包；这将简化解析过程，提高程序的效率。<p>
我们还分别创建了用于描述IP首部和UDP首部的结构体。这些结构体中的各种数据会被packet_handler()合理地定位。<p>
packet_handler(), 尽管只受限于单个协议的解析（比如基于IPv4的UDP），不过它展示了捕捉器(sniffers)是多么的复杂，就像TcpDump或WinDump对网络数据流进行解码那样。 因为我们对MAC首部不感兴趣，所以我们跳过它。 为了简洁，我们在开始捕捉前，使用了<a class="el" href="group__wpcapfunc.html#g64c019f851f7da6892d51cca15f12ace">pcap_datalink()</a> 对MAC层进行了检测，以确保我们是在处理一个以太网络。这样，我们就能确保MAC首部是14位的。
<p>
IP数据包的首部就位于MAC首部的后面。我们将从IP数据包的首部解析到源IP地址和目的IP地址。 
<p>
处理UDP的首部有一些复杂，因为IP数据包的首部的长度并不是固定的。然而，我们可以通过IP数据包的length域来得到它的长度。一旦我们知道了UDP首部的位置，我们就能解析到源端口和目的端口。
<p>
被解析出来的值被打印在屏幕上，形式如下所示：<p>
<code> 1. \Device\Packet_{A7FD048A-5D4B-478E-B3C1-34401AC3B72F} (Xircom t 10/100 Adapter) <br>
 Enter the interface number (1-2):1<br>
</code><p>
<code>listening on Xircom CardBus Ethernet 10/100 Adapter... <br>
 16:13:15.312784 len:87 130.192.31.67.2682 -&gt; 130.192.3.21.53 <br>
 16:13:15.314796 len:137 130.192.3.21.53 -&gt; 130.192.31.67.2682 <br>
 16:13:15.322101 len:78 130.192.31.67.2683 -&gt; 130.192.3.21.53 <br>
 </code>
<p>
最后3行中的每一行，分别代表了一个数据包。
<p>
<a class="el" href="group__wpcap__tut5.html">&lt;&lt;&lt; 上一页</a> <a class="el" href="group__wpcap__tut7.html">下一页 &gt;&gt;&gt;</a> 
<hr>
<p align="right"><img border="0" src="winpcap_small.gif" align="absbottom" width="91" height="27">
documentation. Copyright (c) 2002-2005 Politecnico di Torino. Copyright (c) 2005-2007 
CACE Technologies. All rights reserved.
<br>2007 Translated By <a href="http://www.CoffeeCat.net.cn" target="_blank">CoffeeCat Studio</a>
</p>
